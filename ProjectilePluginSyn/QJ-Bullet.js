//=============================================================================
// RPG Maker MV
//=============================================================================
/*:
 * @plugindesc 弹幕插件[V8.8]
 * @author Qiu Jiu
 * 
 *
 * @help
 *
 * ================================================================
 * 8.6->8.8
 *1.删除插件中无用的部分。
 *2.修复弹幕插件中弹幕图片动画的播放问题，现在弹幕图片动画不会因为打开其他界面而被重置。
 *3.修复BUG。
 *
 * ================================================================
 * 一.插件说明
 * ================================================================
 * 1.本插件有完整的伤害判定系统,既可以作为半事件ARPG系统中判定伤害的核心插件,也可作为
 *   其他ABS插件的扩展,同时自带的粒子和残影效果也可以制作特效。
 * 2.您需要在img/bullets下存放子弹/弹幕图片。
 * 3.减少耗能的方法有:
 *   将事件的默认刚体形状定为 圆形 而非矩形。
 *   减少同一段时间内同时存在的子弹数量。
 * 4.系统加载图片时需要几帧的时间来加载图片,所以一个子弹发射时,若其子弹图片是第一次使用,那么
 *   子弹的图像会延迟几帧才加载出来,对于部分存在和淡出总时长在大概20帧以上的子弹来说此问题
 *   影响甚微。但是对于一些只出现几帧的子弹来说影响很大,所以加入了“预载图片”的功能。
 *   只要在预载栏里把对应的文件名写上,那么系统就会对其进行预载,在第一次使用该图片作为子弹
 *   时不需要延迟加载。
 * 5.本插件挂在itch.io上面进行售卖。仅体验内容可免费下载预览版Demo。若想使用请进行购买授权。
 * 6.在下方 属性名 之后写着*的值可以使用直接变化/渐变效果。
 *   不同的变化点之间使用符号~分隔。一个变化点的格式为 持续时间|要变成的值 或者 持续时间/渐变的目标值。
 *   且第一个变化点实际上是初始值,不能使用 持续时间/渐变的目标值 ,即渐变效果。
 *       例如10|5~30|20~20/30:初始值为5,持续10帧后变为20,再持续30帧,然后在20帧内由20逐渐变为30,即系统自动进行
 *   运算,使这20帧内的对应值分别为20.5 21 21.5 22 22.5 23 23.5 24 24.5 25 25.5 26 26.5 27 27.5 28 28.5 29 29.5 30
 *   渐变的目标值可能是整数,也可能是十六进制颜色,例如10|#00FF00~30|#00FFFF~20/#AABBCC,使用/时颜色也会自动渐变。
 *   基本上系统内使用的度都是角度而非弧度,有/时,系统会将角度转变为弧度,然后再自动添加渐变效果。
 *   在变化完毕后,将会以最后的值作为初值进行循环。
 * 7.子弹的基础属性中的属性 DeadQT/MoveQT/UpdateQT的指令中或者DeadJS/MoveJS/UpdateJS中可以写如下指令:
 *   this.screenShowX()代表此子弹的X坐标。
 *   this.screenShowY()代表此子弹的y坐标。
 *   this.showRotation()代表此子弹图片的角度。
 *   this.showRotationMove()代表此子弹移动的角度。
 *   this.screenShowXLast(num)代表此子弹的上num个X坐标。
 *   this.screenShowYLast(num)代表此子弹的上num个y坐标。
 *   在DeadQT/MoveQT/UpdateQT的指令中可以写如上指令来读取对应坐标,从而在生成新的弹幕时可以让其显示在上一个弹幕的
 *   所在的位置。从而制作各种效果。
 *   事实上this就代表上一个子弹,除此之外还可以读取其他的诸如Speed等数据。
 *
 *   扩展指令：
 *  (1)this.changeAttribute(属性名,属性值);
 *     当前支持修改的属性有：
 *     Img  MoveType  Target   Action   CollisionBox
 *     您能动态修改子弹的图片和移动方式了！
 *
 * 8.<Group:"group id">
 *   将事件归类。若某事件的被触发事件页第一行没有注释,但别的未被触发的事件页的第一行有此注释,此
 *   事件同样不会被攻击到。这样可以配合着做“敌人被击败后不会再被攻击到”的效果。
 *   例如地图上有一些事件:这些事件的第一个事件页的第一行为注释,且注释中写着<Group:"enemy">
 *   且玩家发射的子弹的Target中写["G[enemy]"],那么此子弹只能攻击到上方所说的写着<Group:"enemy">的事件。
 *   若InitialRotation写成"G[enemy]"那么此子弹发射时自动对准写着<Group:"enemy">的那些事件中距离此子弹
 *   发射点最近的事件。
 *
 *   此指令中的两个"符号为旧时技术不佳所致，在6.5中已经修复这个问题，现在加不加"符号均可。
 *   且现在可以让一个事件属于多个group，使用,分割。
 *   以下例子均可以正常运行，且都表示这个事件同时属于enemy和test这两个group(注意都无'和"符号)。
 *   <Group:enemy,test>
 *   <Group:"enemy",test>
 *   <Group:enemy,'test'>
 *   <Group:"enemy",'test'>
 *
 * 9.投掷物一共有三大类：
 *   bullet laser twopoint
 * ================================================================
 * 二.脚本指令与范例
 * ================================================================
 * 1.基础子弹发射:系统预设了一个最基础的子弹的数据,您可以通过下方的这种设置方式来修改
 *   这些默认的数据来发射一个子弹。默认的数据在下方可以查询。
 *
 *   QJ.BL.Shoot({
 *    新属性名:新属性的对应值,
 *    新属性名:新属性的对应值,
 *    新属性名:新属性的对应值
 *   });
 *
 *   例如在默认的基础上修改Action和Anim:
 *
 *   QJ.BL.Shoot({
 *    Action:["SS[A,true]"],
 *    Anim:1
 *   });
 *
 * ===============================================
 *      initialRotation:默认为"PD[]"。子弹的朝向,0-360度。0度时朝上,90度朝右,180度朝下,以此类推。
 *          除此之外还可以写转义字符,包含转义字符时需加英文引号:
 *          "M[]"朝向鼠标。
 *          "PD[]"朝向玩家所在方向。玩家朝右时90度,朝左时270度,以此类推。
 *          "D[数字]"朝向指定事件所朝方向,此事件的朝向为右时为90度,为下时为180度,以此类推。
 *              写0代表本事件。
 *              若数字写0且在公共事件里执行,则该发射子弹的指令无效。
 *          "P[]"对准玩家位置发射。
 *          "E[事件id]"对准事件位置发射。例如"E[5]"即发射时自动对准事件5。
 *          "EV[变量id]"对准由变量指定的事件的位置发射。
 *          "X[数字]Y[数字]"对准某画面XY位置发射,此处是发射时刻的屏幕坐标。例如"X[100]Y[100]"。
 *          "XM[数字]YM[数字]"对准某地图XY位置,此处是发射时刻的地图坐标。
 *          "G[事件集合编号]"对准某个事件集合中距离此子弹发射位置最近的事件发射。
 *          "N[特殊编号]"让此子弹朝向备注中含有[特殊编号]的事件中离发射点最近的事件。
 *          "ESV[mapId,eventId,valuriableId]"在使用Iavra Self Variables.js这个独立开关插件时，可以读取独立变量的值作为事件id，然后朝向那个事件。
 *               valuriableId就是tag。mapId可以写0，写0时代表当前地图。但eventId不能写0。
 * ===============================================
 *      x/y:默认为"P[]"。发射时的X位置和Y位置,此处是发射时刻的屏幕坐标,填整数。
 *          "M[]"代表鼠标的X/Y位置。
 *          "P[]"代表玩家的X/Y位置。
 *          "E[0]"代表本事件。
 *          "E[事件id]"代表指定id的事件。
 *          "B[index]"某个子弹的x/y坐标。每一个子弹都有一个特殊的编号。
 *              此指令是专用于DeadQT/MoveQT/UpdateQT或DeadJS/MoveJS/UpdateJS中的转义词。
 *              在DeadQT/MoveQT/UpdateQT或DeadJS/MoveJS/UpdateJS中使用this.index获得当前子弹的编号，从而让新生成的
 *              子弹显示在原先子弹所在的位置。格式为: "B["+this.index+"]"
 *              "B[index,num]"则指这个子弹的第上num个坐标。
 *          "G[事件集合编号,orginX,orginY,MaxRange,num]"读取某个事件集合中距离点(orginX,orginY)的距离小于MaxRange的
 *              第num个近的事件的X/Y位置。num写1时代表最近的事件。
 *              orginX/orginY即可写数字,也可写M[]/P[]/E[0]/E[事件id]。（不可再嵌套,若想做特殊的效果请联系我）
 *              这里的MaxRange和num可以省略不写，不写时即指最近的事件。
 *          "GR[事件集合编号]"读取某个事件集合中随机事件的X/Y位置。
 *              如果x和y中都有GR的话,那么x和y中GR所选取的随机事件将相同。
 *          "GRR[事件集合编号,orginX,orginY,MaxRange]"读取某个事件集合中某个随机事件的坐标,且这个事件与点
 *              (orginX,orginY)之间的距离必须小于MaxRange(px),如果在这个范围内没有敌人则无法攻击。
 *              如果x和y中都有GRR的话,那么x和y中GRR所选取的随机事件将相同。
 *          !!!注意,G,GR,GRR不能共存!!!
 * ===============================================
 *      z:默认为"C[]"。子弹的Z值,可以填:
 *           "T[]"让子弹显示在地图下,玩家与事件之下,图片之下。
 *           "M[]"让子弹显示在地图上,玩家与事件之下,图片之下。
 *           "C[]"让子弹显示在地图上,玩家与事件之上,图片之下。
 *           "P[]"让子弹显示在地图上,玩家与事件之上,图片之上。
 * ===============================================
 *      scaleX*:默认为100。子弹图像的横向（宽度）放大率,单位为%。
 *          可以写类似"0|100~10|200~20|300"的格式用来设计动态放大缩小的效果。
 *          即在初始时放大率为100,第10帧时变为200,第20帧时变为300。长度可变。
 * ===============================================
 *      scaleY*:默认为100。子弹图像的纵向（高度）放大率,单位为%。
 *          可以写类似"0|100~10|200~20|300"的格式用来设计动态放大缩小的效果。
 *          即在初始时放大率为100,第10帧时变为200,第20帧时变为300。长度可变。
 * ===============================================
 *      MoveType:默认为"S[]"。子弹的移动类型,代表不同的移动方式。
 *           "S[]"发射后角度不变,直直地向前走（Straight）。0
 *           "TP[最小转角]"发射后追踪玩家（Trace Player）。1
 *           "TE[最小转角,事件id]"发射后追踪指定id的事件（Trace Event）。2
 *           "TEV[最小转角,变量id]"发射后追踪数字所指定的id的事件（Trace Event Base On Variable）。3
 *           "TG[最小转角,事件集合编号]"追踪某个事件集合中距离此子弹最近的事件（Trace Group）。4
 *           "TN[最小转角,特殊编号]"对备注中含有[特殊编号]的事件中离发射点最近的事件进行追踪（Trace Nobi）。7
 *           "QP[一倍宽度,发射角度,一倍时间,次数]"让此子弹的轨迹为抛物线（Quadratic parabola）。6
 *                  此选项需要考虑的因素比较多,所以若想使用,请使用预设QJ.BL.Shooter_HandGrenade.
 *           "B[指定id,朝下x偏移,朝下y偏移,朝左x偏移,朝左y偏移,朝右x偏移,朝右y偏移,朝上x偏移,朝上y偏移]"
 *                  发射后让此子弹粘附在某事件上,不会移动。速度大于0时也不会移动。        5
 *                  指定id:-1玩家 0当前事件 其他数字代表指定事件。基础项为为"B[-1,0,0,0,0,0,0,0,0]"
 *           "F[函数]"使用函数来定义路径,具体输入可参考Particles下的moveType。（function）
 *                  例如直线为:"F[-8*t;0]"或"F[-8*t|0]"。       8
 *                  注意！使用此轨迹后,ReBound参数将无效,也就是使用此移动类型的子弹无法反弹！
 *                  注意！使用此轨迹后,与速度有关的参数（包括speed）也将无效！
 *           "C[]"子弹不会进行自主移动，但是会不断读取x/y/initialRotation的值作为其x/y/rotation值。 9
 *                  使用此数据后，ReBound等部分功能无效。此值只用于在x/y/initialRotation为"B[index,num]"时使用！！
 *           "CI[characterId,radius,speed]"   或者   "C[characterId,radius,speed,trace speed]"            10
 *                  使弹幕围绕指定角色不断旋转。
 *                  各个属性为：
 *                  characterId:事件id，写-1为玩家。
 *                  radius:环绕事件的半径
 *                  speed:移动速度。此处设置了速度后，QJ.BL.Bullet({})的speed属性就无用了。
 *                  trace speed:追踪速度，若此值为0则子弹会瞬间回到轨道内。若大于0则对目标轨道进行追踪。
 *           "QB[对象编号/事件集合编号/特殊编号]"       11
 *                  使子弹沿着贝塞尔曲线去追击敌人。
 *                  相比TP，TE和TG更加自然，不会绕圈，但此指令不是实时追踪敌人，在子弹生成时即计算好了轨迹，轨迹在生成后就固定了。
 *                  ***使用此移动类型后，子弹的速度根据二次贝塞尔曲线和此子弹的speed属性的值自动变化，speed属性最好写12到24***
 *                  各个属性为：
 *                  对象编号：写-1是玩家，写0是本事件，写大于0的数字是指定事件。   例如   "QB[1]"
 *                  事件集合编号：不再解释。   例如   "QB[enemy]"
 *                  特殊编号：不再解释。   例如   "QB[[T]]"   (的确是有两个中括号嵌套)
 * ===============================================
 *      rTRotation:默认为""。特殊的旋转角度附加。
 *          可以写类似"10|30~50|15~100|-20"的格式来指定在某时刻突变的角度。
 *          注意！此处是指定时间变化,不能使用/,不能循环。
 *          即在第10帧时突然顺时针旋转30度,第50帧时突然顺时针旋转15度,第100帧时突然逆时针旋转20度。
 * ===============================================
 *      bTRotation:默认为""。特殊的旋转角度附加。指定每个时间点突变的角度。
 *          例如："60|0~10|0.02~20/0.22"。分隔符使用|时代表匀速，使用|代表匀加速，使用%代表曲线变加速。
 *          在子弹发出的前60帧内没有变化，第60-70帧时每帧增加0.02度，70~90帧时每帧增加一定角度，
 *          此一定角度从0.02变化到022，即在70帧增加0.02度，71帧增加0.03度...89帧增加0.21度，90帧增加0.22度。
 *          注意！这个属性是说每帧都增加，且单位是 度每帧 所以实际上这些角度的数值应尽量得小一些才能看清效果。
 * ===============================================
 *      Regions:默认为[]。子弹消失的区域id列表,当子弹与列表中包含的区域相碰撞时子弹消失。
 *              例如写[1,5]时子弹在碰到区域1或5时消失。
 * ===============================================
 *      Terrains:默认为[]。子弹消失的地形id列表,当子弹与列表中包含的地形相碰撞时子弹消失。
 *              例如写[1,5]时子弹在碰到地形1或5时消失。
 * ===============================================
 *      Target:默认为[]。此子弹可以打中的事件的列表,可以在[]中写下面的语句,不同的语句间用,隔开。
 *          "E[事件id]"让此子弹可以打中某id的事件,除非此事件被执行了“暂时消除事件”的指令,否则
 *              子弹一直能打到该事件。
 *          "G[事件列表的id]"我们可以在一个事件的某个事件页的第一行中写<Group:"事件列表的id">。
 *              当该事件的当前事件页为该事件页时,该事件就能被target中有"G[事件列表的id]"的子弹打到。
 *              例如<Group:"enemy">和"G[enemy]",可查看范例来进一步理解。
 *          "EV[数字]"让此子弹能够攻击当前地图上由变量指定的某id的事件。
 *          "P[]"让此子弹能够攻击玩家。
 *          "Nobi[T]"我们可以在某个事件的备注中写[特殊编号],那么此子弹就能攻击到该事件。
 *              例如在某些事件的备注中写[T],而这里写["Nobi[T]"],那么子弹将能够攻击到这些事件。
 *
 *          ***扩展功能***(为特定的专用功能，非必要不建议使用)
 *          上方的数值可以写成数组，后边可以加一个额外的判定条件，例如["P[]","$gameSwitches.value(2)"]
 * ===============================================
 *      Pierce:默认为0。子弹的穿透能力,写数字代表穿透次数,只能写大于等于0的整数。
 *          使用此功能可以做穿透弹。穿透只能穿透事件,无法穿透设为墙壁的区域和地形。
 *          写0:此子弹在第一次与别的事件相接触后就消失。
 *          写其他正整数 :此子弹可以穿透几次。
 * ===============================================
 *      Img:默认为"bullet0"。图片文件名。此处图片放在游戏目录的img/bullets下。
 *          可以在电脑/手机本地的图片文件名的后边写[帧数,速度]。也就是[frames,speed]。
 *          例如写flash1[4,5]时,整个图片被纵向切成四竖列,然后由左到右循环播放,每两竖列间等待5帧。
 *          也可以写[x frames,y frames,speed]就可以既横向切割也竖向切割。
 *          
 *          除了直接写文字(整体加上英文引号)来设置子弹的插件外,也可以直接复制此刻某个事件/玩家此刻的行走
 *          图来制作残影,需要写数组(整体不加引号):
 *          [0,目标id]
 *          0是固定的数字,不能修改,以便以后扩展其他功能。使用此功能时,下方的AnchorY将默认为1而非0。
 *          目标id写-1时复制此刻玩家的行走图,0为本事件的行走图,大于0的数为指定id的行走图。
 *          例如写[0,-1]可以将当前玩家的行走图作为子弹的外形。
 *          
 *          当然也可以直接将文字作为弹幕发射出去:
 *          [1,文字内容,文字颜色,文字字号,文字排列方式,文本子弹最大宽度,文本子弹最大高度,描边颜色,描边粗细]
 *          文字颜色/描边颜色:十六进制颜色或者渐变["0|初始文字颜色~1|终止文字颜色",角度]
 *              渐变的设置较为复杂。渐变的出发点是文字的左上角，渐变的方向即为角度(单位为度)。
 *              若想让文字由上到下渐变，角度应该写180，从左到右渐变，角度应该写90。
 *              "0|初始文字颜色~1|终止文字颜色"实际上是从0到1逐渐设置渐变颜色改变的关键点。
 *              类似的诸如"0.2|#00ff00~0.8|#00ffff"或"0|#00ffff~0.5|#aabbcc~1|#ddeeff"等的数据都可以
 *          文字排列方式:0竖排  1横排
 *          文本子弹最大宽度/文本子弹最大高度:写0时自动进行适配。
 *
 *          当然可以直接用图标。
 *          [2,图标编号]
 * ===============================================
 *      Anim:默认为0。子弹消失后播放的动画id。写0时不播放动画。
 *          除了写数字外也可以写数组来分别指定子弹播放的动画，写0时代表此状态下不播放动画.
 *          [正常击中敌人时的动画id,碰到墙壁时播放的动画,达到Max中指定的条件时播放的动画]
 * ===============================================
 *      DeadCount:默认为0。子弹在要消失的时候,执行消失动画所需的时间,单位为帧数。
 *          注意！子弹接触到可以触碰的事件的时候,首先执行Action,然后播放动画,播放动画的同时进行淡出。
 *          淡出效果在插件参数中可以指定。
 *          当子弹动画播放完且淡出成功（不透明度已经是0了）的时候子弹完全消失（被清除）。
 * ===============================================
 *      DeadScale:默认为100,即不放大。子弹在要消失的时候,在DeadCount期间内放大的倍数。
 * ===============================================
 *      Speed*:默认为12。子弹运动的速度,写正整数,单位是像素/每帧。一般来说,这里的速度写6-28比较好。
 *          除了写数字外,也可以写例如"0|6~4|12~8|18"格式的字符串。这个字符串的意思是在子弹运行的第
 *          0帧时移速变为6,在4帧时移速变为12,在8帧时移速变为18。
 *          基础格式为"0|初始速度~第一次移速改变的帧数|第一次移速改变为多少~第二次帧数|第二次移速~……"。
 *          每个改变的时刻与速度中间用|分割,然后再用~分割不同的变化次序。
 *          又例如,"0|0~60|12~120|24"代表发射后一秒内不动,接下来一秒以12的速度运动,再接下来的
 *          一秒以24的速度运动。
 *          （写负数将产生无法预知的bug,要想让子弹拐弯请使用rTRotation参数来指定。）
 * ===============================================
 *      Max:默认为120。子弹能够移动的帧数。
 *          也就是说,这里的Speed是速度,Max是时间,Speed乘Max就是移动的最大像素数（路程）。
 *          -1:永远存在,只有使用通用的删除弹幕指令或者在指定当前子弹的Name属性后使用QJ.BL.deleteBullet(Name);才可以删除。
 *          "S[id,true/false]":设置当某开关打开/关闭时子弹消失。
 *          "SS[EventId,A/B/C/D,true/false]":设置当某事件的独立开关开关开启/关闭时取消。
 *              EventId写0时代表本事件id,只在此指令是在事件中执行时才有效。
 *          "T[内容]":执行内容,获取其结果作为布尔值来判断,结果为true时子弹消失。
 * ===============================================
 *      RotationAuto:默认为-1。
 *          写-1:无效果。
 *          写0-360的正整数:固定旋转角度。
 *          写361-1080的正整数:“运动的转角”与“图片本身的转角”不同步。且 此数字减720 代表旋转速度(减720后可为负时逆时针,减720后可
 *              为正时顺时针),单位为度/帧。
 * ===============================================
 *      Action:默认为[]。触发后执行的指令的列表。
 *          "C[公共事件id]"执行公共事件。
 *          "S[id,value]"将某开关打开或者关闭。此处value只能填true或者false。例如"S[1,true]"代表打开1号开关。
 *          "SS[id,value]"将被攻击到的事件的某独立开关打开或者关闭,例如"SS[A,true]"
 *          "E"对被攻击到的事件执行“暂时消除指令”,这个指令在事件指令的第二页的“人物”那一栏的最后一行。
 *          "C[公共事件id,要传入的参数1,要传入的参数2……]":执行公共事件,且传入参数。
 *              (1)可以在公共事件中访问传入的参数,例如this.BP[1]代表要传入的参数1。（Bullet Param）
 *              (2)可以在公共事件中用this.EID访问此时子弹击中的事件的id。
 *              this.EID等于-1时说明打到了玩家,this.EID等于0时说明没有打到玩家或事件,this.EID等于其他数字时说明打到了
 *              某id的事件。
 *              (3)可以直接在公共事件的各指令中使用this.EID或者this.BP[参数编号]。
 *              (4)例如:此处写"C[5,10]",假设此子弹碰撞到id为3的事件,那么this.BP[1]就是10,this.EID就是3。
 *              (5)可以用this.bullet.x和this.bullet.y获得子弹消失时的位置。
 *              (6)可以使用this.bullet.x和this.bullet.y来获得此时此子弹的坐标。
 *                 可以使用这个值来制作更丰富的子弹。
 *              (7)可以使用this.ifPierce来判断子弹是不是因为穿透而触发了Action(pierceAction被开启时就可能发射生穿透时也执行Action的情况)。
 *          "CP[id]":直接额外执行“被攻击到的事件”的某一个事件页,此处即指Rpg Maker 2000/Rpg Maker 2003中的那个
 *              “事件呼叫”中呼叫特定事件的某个事件页的功能。
 *              此功能也可以直接用QJ.BL.CallEvent(事件id,事件页id)来执行（相当于本脚本的额外功能,主要
 *              目的是方便做“事件与脚本混合”的那种ARPG）。
 *          "T[语句]"执行脚本。
 *              脚本中bulletX/bulletY可获得子弹/触发行动点的坐标,bullet获得子弹数据,tarCharacter获得
 *              对象数据，ifPierce来判断子弹是不是因为穿透而触发了Action。此项配合eval(QJ.BL.QuickText(预设编号))
 *              或者QJ.BL.Quick(预设编号,{})指令会很方便。
 *
 *          ******以下为一些Action的特殊用法，主要面向有一定JS基础的人******
 *
 *          ["C",commonEventId,value2,vlaue3……]      同上方的     "C[公共事件id,要传入的参数1,要传入的参数2……]"   不过因为不将数据转成字符串，
 *              所以可以直接将对象地址写在value2,vlaue3……中.其中的"C"是固定的字符，方便以后扩展其他功能。
 *              同样在对应的公共事件中可以使用this.EID   this.bullet   this.BP访问数据，其中的this.BP即是此处的
 *              ["C",commonEventId,value2,vlaue3……],比如在执行的公共事件中调用this.BP[2]获得的就是value2.
 *
 *          ["CP",pageIndex,value2,vlaue3……]    同上方的    "CP[id]"   不过因为不将数据转成字符串，所以可以直接将对象
 *              地址写在value2,vlaue3……中.其中的"CP"是固定的字符，方便以后扩展其他功能。且可以自由设置额外的数据。
 *              同样在对应的事件页中可以使用this.BP访问数据，其中的this.BP即是此处的["CP",pageIndex,value2,vlaue3……]
 *              比如在事件页中调用this.BP[2]获得的就是value2。
 *              实际上这样做后，子弹在攻击到敌人时就会自动调用脚本指令：
 *              QJ.BL.CallEvent(事件id,事件页id,额外的数据)
 *              这个指令就会在不影响事件页原本的执行情况的前提下额外执行事件页，
 *              其中的   额外的数据    在对应事件页中就可以使用   this.BP   获取到。
 *
 *
 * ===============================================
 *      CollisionBox:默认为"R[4,4]。"子弹的碰撞体积,我们设计一个图形用来代表此子弹的碰撞体积,此设定与事件的碰撞体积相同。
 *          "C[半径]"（Circle）以子弹图片的正中心为原点,画一个圆代表此子弹的碰撞体积。
 *              使用此碰撞体积时,AnchorX,AnchorY,scaleY这三个值无效。scaleX指整个圆的缩放(即圆无法变为椭圆。)
 *          "R[宽,高]"（Rectangle）以一个长方形为碰撞形状。
 *              使用此碰撞体积时,ReBound这个值无效,即子弹无法反弹。
 * ===============================================
 *      Tone:默认为[0,0,0,0]。色调,格式为[红,绿,蓝,灰度],这里的“红,绿,蓝,灰度”与事件指令“更改画面色调”中的
 *          色调是一个意思,正常情况下是[0,0,0,0],纯红是[255,-255,-255,0],纯黑是[0,0,0,255]。
 * ===============================================
 *      Blend:默认为[0,0,0,0]。覆盖颜色,格式为[红,绿,蓝,不透明度]。
 * ===============================================
 *      Hex:默认为0。色相（只在子弹Img为图片时有效）,写0到360的数字，和数据库中动画资源的“色相”一个意思。
 * ===============================================
 *      Opacity*:不透明度,范围是0-255。 正常情况下写0即可。
 *          可以写类似"0|255~10|200~20|255"的格式用来设计动态变化的效果。
 * ===============================================
 *      AfterImage:默认为[]（即不显示残影）。残影的相关设置。要设置残影需要写一个数组:
 *          [颜色,初始不透明度,最大存在时间,宽度]  例如["#FF0000",150,10,0]
 *          颜色:十六进制的颜色表示方式,例如"#FF0000"。这里的颜色也可以动态指定。
 *              ["0|#0000FF~10/#00FF00~10/#FF0000~10/#0000FF",150,10,0]
 *              子弹初始拖尾效果为蓝色(#0000FF),然后在10帧内逐渐变为绿色(#00FF00),然后在10帧内逐渐变为
 *              红色(#FF0000),然后在10帧内逐渐变回蓝色(#0000FF),然后循环。
 *          初始不透明度:不透明度。
 *          最大存在时间:最大存在时间*长度=残影的最大长度,残影的不透明度会从发出点到最大长度逐渐变化,由初始不透明度变到0。
 *          宽度:残影宽度,若写0则自动读取子弹图片的宽度,若想指定宽度则写其他数字。
 *              这里的宽度可以写类似的特殊的数值："4|12~6/1"，这里|或者/前的数字之和最好等于前面的“最大存在时间”。
 *              否则效果不一定好。
 * ===============================================
 *      Light:默认为{}（即不显示光效）。在子弹附近显示光效。在同时装有QJ-Lighting.js的前提下此
 *          选项才能起效,在子弹附近显示光效。
 *          {}中可以写的参数有：
 *              lightId:“简易灯光”的灯光id(默认为"",即不显示灯光)
 *              synRotation:是否同步子弹图像的朝向和灯光的朝向
 *              force:默认为false。在使用根据帧率来决定特效是否显示的功能时，帧率太低绑定在该插件上的灯光也会不显示。
 *                    若想强制灯光显示，不管fps时则需将此项设置为true。
 * ===============================================
 *      Particles:默认为[]（即不启用粒子效果）。
 *          在子弹附近显示粒子效果,注意,此项较为复杂,所以若想制作简单的效果,请使用预设。
 *          []中可以写粒子数据,粒子数据{}中可以写的参数有:
 *          img:"gas"或者"gas[5,5]"之类的。
 *          offsetX:粒子发射点相对子弹中心的偏移。
 *          offsetY:粒子发射点相对子弹中心的偏移。
 *          dir:发射方向,此方向是相对子弹方向的方向。注意此处单位为弧度而非角度。
 *          dirOffset:发射方向的最大偏移范围,写0则不偏移。注意此处单位为弧度而非角度。
 *          max:最大存在时间。
 *          deadCount:淡出时间。
 *          opacityMin:初始最小不透明度。注意此处的范围为0-1而非0-255。
 *          opacityMax:初始最大不透明度。注意此处的范围为0-1而非0-255。
 *          scaleMin:最小放大率。注意此处的范围为0-1而非0-100。
 *          scaleMax:最大放大率。注意此处的范围为0-1而非0-100。
 *          moveType:移动方式,此处写过零点且在移动范围内连续(否则效果会很奇怪或者无效)的参数函数。
 *              默认为"-8*t;0",其中;符号分割x和y。以粒子所朝方向为x轴正半轴,以此轴顺时针方向旋
 *              转90度为y轴建系的话,粒子存活t帧时,粒子的相对坐标就为(-8*t,0),即x=-8*t,y=0,也就是粒子将匀速后退。
 *              此处函数不过零点或者函数过于复杂将导致无法预知的问题,若想简单使用请使用
 *              预设,若想做复杂的效果请联系我。
 *              可能可以用到的值:
 *              ***默认后退"-8*t;0".
 *              ***正弦抖动(其中24和3为可调值)"-8*t;24*Math.sin(t/3)"粒子会朝左右摆动.
 *              ***螺线旋转(其中2为可调值)"t/2*Math.cos(t/2);t/2*Math.sin(t/2)"粒子会以生成点为
 *                  圆心进行旋转半径逐渐增大的圆周运动,也就是绕螺线运动.
 *              为了有更好的效果,此处也支持极坐标方程,使用极坐标方程时应用|分割。
 *              若一个极坐标方程为ρ=sin(θ),则此时应该写"Math.sin(t)|t",以t代替θ进行动态选变化。
 *              |前的式子中t代表时间,总会变化。t后的数字代表t与θ的关系,故实际上是"ρ(t)|θ(t)".
 *              ***默认后退"-8*t|0".
 *              ***三叶玫瑰线"144*Math.sin(3*t/180)|t/180"
 *              ***注意！为了优化粒子轨迹运算,若此值的后几位为 *t;0 或者  *t|0   时,将默认定为直线
 *                 轨迹,并读取前面的数字为速度,以大幅度地优化运算速度***
 *          wait:两次发射粒子的间隔。单位是0。
 *               发射的间隔与弹幕的移速同时影响粒子的效果。
 *               写负值时代表不是时间间隔而是距离间隔，每次弹幕移动时都进行自动补帧，且下方的num属性将无效，建议写-2。
 *          num:一次发射的粒子数量。
 *              默认参数的粒子为:
 *              {
 *              img:null,
 *              offsetX:0,
 *              offsetY:0,
 *              dir:Math.PI,
 *              dirOffset:Math.PI/6,
 *              max:30,
 *              deadCount:60,
 *              opacityMin:0.5,
 *              opacityMax:1,
 *              scaleMin:0.5,
 *              scaleMax:1.5,
 *              moveType:"-8*t;0",
 *              wait:2,
 *              num:1,
 *              }
 * ===============================================
 *      AtkRange:默认为0。攻击范围,写数字。
 *          若此处写0,则子弹在碰到指定敌人事件后便执行一次Action,然后消失。若碰到上方指定的
 *          区域或者地形,或者到达最大持续时间,那么直接消失（ReBound是true则是反弹）。
 *          若此处写大于0的数字,则子弹在碰到指定敌人事件后,不针对该敌人进行一次Action,而是
 *          以子弹消失位置为中心创建一个临时的圆形碰撞体,这里的数字就代表圆的半径,然后对检测
 *          到的敌人均执行一次Action。
 * ===============================================
 *      WaitBaseOnSpeed:默认为-2。此项可填以下数字:
 *          -2无效果。
 *          -1该子弹无法攻击敌人。但是可以通过打开DeadAction或NoCollisionAction
 *          （不包括PierceAction）且使AtkRange>0来使该子弹在碰到墙壁或要消失时进行一次范围攻击。此功能的
 *          主要目的是用来做倒计时炸药,在抛射的中途不会攻击,而是在撞到墙或者要消失（计时快结束）时才进行
 *          攻击。
 *          0该子弹的速度为0时才能攻击敌人和碰撞墙壁。此功能主要是用来做触发试地雷,在地雷被抛射（地雷枪）或放置时
 *          （此时作为地雷的子弹速度不是0）无法攻击敌人,在放置完成（不再移动,速度为0）时才可以攻击敌人。
 *          大于0的整数:只有当子弹的速度为此值时子弹才能攻击敌人。
 * ===============================================
 *      DeadAction:默认为false。当子弹没有击中敌人,而是碰到上方指定的区域或者地形时,
 *          是否执行一次范围检测,此项只在上方的AtkRange非0时起效。
 * ===============================================
 *      PierceAction:默认为false。穿透时是否执行Action。
 *          当此项为true且上方指定的Pierce的值大于0时,子弹在穿透敌人时也会对敌人造成伤害。
 *          且上方指定的AtkRange大于0时,在穿透处进行范围检测。
 * ===============================================
 *      NoCollisionAction:默认为false。子弹到达最大存在时间时还未触碰到墙壁或事件时,若AtkRange>0
 *          则是否在消失处进行一次范围检测。
 *          注意,此项能执行说明子弹没有直接攻击到敌人,那么AtkRange要大于0。
 * ===============================================
 *      DeadAnim:默认为true。子弹到触碰到墙壁或事件时,是否显示动画。
 * ===============================================
 *      PierceAnim:默认为false。子弹进行穿透时,是否显示动画。
 *          子弹进行穿透时,也在进行移动。所以在看到动画播放时,子弹可能已经走远了。
 * ===============================================
 *      NoCollisionAnim:默认为false。子弹到达最大存在时间时还未触碰到墙壁或事件时,是否显示动画。
 *          注意,此项能执行说明子弹没有直接攻击到敌人,那么AtkRange要大于0,否则会出bug。
 * ===============================================
 *      ReBound:默认为0。子弹反弹次数,子弹可以在碰到指定的地形或者
 *           区域时进行反弹,反弹与穿透（Pierce）无关,且无法在碰到事件时反弹。
 *           若想使此功能起效，子弹的碰撞体积必须是圆形。
 * ===============================================
 *      AnchorX:默认为0.5。子弹图片的中心横向描点,范围为0-1。
 * ===============================================
 *      AnchorY:默认为0.5。子弹图片的中心纵向描点,范围为0-1。
 * ===============================================
 *      LMD:默认为true（即Leave Map Disappear）。
 *          若此选项为true则当子弹移动到地图（不是屏幕）外围时子弹直接消失。此功能可以用来直接删掉
 *          一些已经无用的超过地图的子弹。
 *          若为false时则不这么做。
 * ===============================================
 *      Bit:默认为false。打开此开关后子弹将不会进行碰撞检测。
 * ===============================================
 *      UpdateJS:默认为""。写字符串,子弹运行时的每帧都会对此字符串执行eval。
 *          此处可以使用this来获取子弹对象,this的screenShowX和screenShowY函数可调取当前子弹位置,
 *          this的rotationMove可调取当前子弹的移动角度。
 * ===============================================
 *      MoveJS:默认为[]。指定子弹在移动到几帧之后,开始每隔几帧循环执行某个脚本。
 *          基础格式为[循环前等待时间,一次循环的等待时间,一次循环时执行的脚本]
 *          其中 循环前等待时间 和 一次循环的等待时间 必须大于等于0,一次循环时执行的脚本必须为字符串。
 *          例如[[60,5,"console.log(this.speed)"],[0,5,"console.log(this.x)"]]
 *          在子弹运行的60帧后,向控制台输出一次子弹的速度,然后每隔5帧都向控制台输出一次子弹的速度。
 *          在子弹刚开始运行的时候向控制台输出一次子弹的x坐标,然后每隔5帧都向控制台输出一次子弹的x坐标。
 *          其余同UpdateJS。
 * ===============================================
 *      DeadJS:默认为""。写字符串,在子弹消失时执行Action前必定执行的额外脚本。
 *          在此脚本中有值deadMode。
 *          deadMode为0时代表子弹在打到敌人后正常死亡。
 *          deadMode为1时代表子弹在打到指定区域或者地形后死亡。
 *          deadMode为2时代表子弹达到最大存在时间后直接消失。
 *          deadMode为3时代表子弹遇到未知的严重错误后直接消失。
 *          其余同UpdateJS。
 * ===============================================
 *      UpdateQT:默认为""。写字符串,代表文字预设指令id。子弹运行时的每帧都会执行文字预设指令中指定id的指令。
 *          文字预设指令中详细的文本内容同UpdateJS。
 * ===============================================
 *      MoveQT:默认为[]。指定子弹在移动到几帧之后,开始每隔几帧循环执行文字预设指令中指定id的指令。
 *          基础格式为[循环前等待时间,一次循环的等待时间,文字预设指令id]
 *          其中 循环前等待时间 和 一次循环的等待时间 必须大于等于0,文字预设指令id必须为字符串。
 *          例如[[10,5,"test1"]]
 *          在子弹运行的10帧后,执行一次文字预设指令test1中的指令,然后每隔5帧都执行一次文字预设指令test1中的指令。
 *          文字预设指令中详细的文本内容同MoveJS。
 * ===============================================
 *      DeadQT:默认为""。写字符串,在子弹消失时执行Action前必定执行的文字预设指令中指定id的指令。
 *          文字预设指令中详细的文本内容同DeadJS。
 * ===============================================
 *      name:为弹幕指定一个特殊的编号。
 *          若想为一个子弹添加多个编号则使用|分割。例如"bullet|atk|person"
 *          可以使用QJ.BL.deleteBullet(Name);来直接删除指定编号的弹幕，不会触发动画和行动。
 *          或者使用QJ.BL.setBulletDisappear(Name);使指定编号的弹幕因到最大时间而正常消失，触发动画和行动。
 * ===============================================
 *      noPassDo:默认为false。在不可通行图块触发碰撞效果。
 *          打开此效果后，上方的区域(Regions)和地形(Terrains)碰撞将被屏蔽。  
 * ===============================================
 *      blendMode:合成方式，默认为0。
 *          0为正常NORMAL
 *          1为加法ADD
 *          2为乘MULTIPLY
 *          3为屏幕SCREEN
 * ===============================================
 *       clearProjectile:默认为""。在其他子弹碰到此子弹时其他子弹将会被消除。
 *          此处写的是子弹的编号(属性name)。有多个时使用|分割。
 *          注意！只有bullet子弹能被消除。
 * ===============================================
 *       cancalEachOther:默认为true
 *          若有两个子弹，一个子弹的属性有：    name:'enemy',clearProjectile:'player',
 *          而另外一个子弹有属性：             name:'player',clearProjectile:'enemy',
 *          那么当这两个子弹碰撞时，两个子弹并不能完全互相消除，只有一个会被消除，哪个会被消除取决于子弹生成的顺序，
 *          此时先生成的子弹会消除后生成的子弹，但后生成的子弹不会消除新生成的子弹。
 *          为两个子弹都再加一个属性：
 *          cancalEachOther:true,
 *          则可以让两个子弹在碰撞时，无论哪个先生成，都一下子被消除。
 * ===============================================
 *   onScreen：默认为false。是否子弹固定于屏幕。此值为true时，若画面相对于地图移动，则子弹也将随之移动，保证子弹
 *             相对于游戏画面的位置不变。
 * ================================================================
 * 2.以玩家或者某事件所在朝向为基础,精细化设定发射点,在一定角度的范围内发射一定数量的子弹。
 *   QJ.BL.Shooter_CharacterAtk(character,{},[ox2,oy2,ox4,oy4,ox6,oy6,ox8,oy8],[r1,r2,num,l]);或
 *   QJ.BL.Shooter_CharacterAtk(character,{},[ox2,oy2,ox4,oy4,ox6,oy6,ox8,oy8]);
 *
 *   character:写数字,-1为玩家,0为本事件,大于0为指定id的事件。
 *
 *   [ox2,oy2,ox4,oy4,ox6,oy6,ox8,oy8]:为各朝向的具体xy偏移。
 *
 *   [r1,r2,num,l]:
 *   r1和r2为附加的角度,r1为附加的起始角度,r2为附加的终止角度。
 *   num为在这个范围内发射的子弹数。
 *   l为角度波动数。子弹在某范围内一般是均匀分布,l等于0时无效果,l大于0时
 *   会使角度在l度内波动。
 *
 *   而{}是要发射的子弹的额外数据,与1中的设置相同,此函数的每一个子弹都会
 *   被赋予这些数据。额外数据很明显不包括initialRotation。
 *
 *   也可以用QJ.BL.Shooter_ArcRange(initialRotation,{},[r1,r2,num,l])
 *   来直接在指定角度内发射子弹。
 * ================================================================
 * 3.调用预设:
 *   直接调用插件参数中“预设指令”中的指令,然后在此基础上进行修改。
 *   QJ.BL.Quick(预设编号,{})
 * ================================================================
 * 4.执行当前地图某事件的事件页中的指令（额外功能,用于某些ARPG的制作,不用可以忽略）
 *   QJ.BL.CallEvent(事件id,事件页id)
 * ================================================================
 * 5.清除所有子弹
 *   QJ.BL.ClearAll()
 * ================================================================
 * 6.打开或者禁用鼠标/手指点击移动。
 *   如果点击能同时让玩家移动,又能让玩家发射子弹,那会让情况变得……很怪异。
 *   QJ.BL.SetMove(true)允许原本的点击移动
 *   QJ.BL.SetMove(false)禁用原本的点击移动
 * ================================================================
 * 7.在指定地方构造碰撞体,对与此碰撞体碰撞到的目标执行action。
 *   碰撞体进行一次检测后便直接消失。相当于一个闪现的子弹。
 *   QJ.BL.DirectAction(X,Y,CollisionBox,Action,Target);
 *   各个数据与1中的数据相同。
 * ================================================================
 * 8.获得此时子弹的数量
 *   $gameMap.bulletsNumber()
 * ================================================================
 * 9.角色残影
 *   QJ.BL.Shadow(id,{})
 *   id是指谁产生残影,-1是玩家0是本事件,大于0的整数是别的事件。
 *   {}中写可调的参数。
 *
 * ================================================================
 * 10.以玩家角色为中心投掷投掷物。
 * QJ.BL.Shooter_HandGrenade({},oneLength,oneTime,maxReBound);
 * ***注意,此指令使用的是moveType中的"QP[一倍宽度,发射角度,一倍时间,次数]",并进行一些
 *  系统性的数值调整以做出抛射效果。在此情况下{}中不要设定Speed和MoveType参数。***
 * ***若投掷物在弹跳结束前提早消失,那么原因是{}中Max的值小于oneTime*maxReBound,
 *  导致弹跳前就达到最大存在时间。此处Max的值最好大于oneTime*maxReBound。***
 * ***此指令预设了AtkRange的值为96,以便范围攻击。
 *
 *
 *  oneLength:单次弹跳距离
 *  oneTime:单次弹跳时间
 *  maxReBound:最大弹跳次数
 *  
 * 默认值:
 * QJ.BL.Shooter_HandGrenade({Img:"xzd"},56,30,3);
 *
 *
 * ================================================================
 * 11.以角色或事件为中心发射文字永远朝下的文字弹幕。
 * QJ.BL.Text(text,color,fontsize,linecolor,linewidth,character,{});
 * text:文字内容
 * color:文字颜色
 * fontsize:文字大小
 * linecolor:文字描边颜色
 * linewidth:文字描边大小
 * character:角色,-1时指玩家,0指本事件,大于0指指定事件。
 *
 * ***注意,此指令在指定了character后,{}内不能再写x/y/initialRotation等参数***
 *
 * ================================================================
 * 12.朝一个方向发射多个子弹,多个子弹在发射点附近排布为圆形,整体朝一个方向发射。
 * QJ.BL.Shooter_C({},r,speed,roSpeed,number,initRotation,x,y) 
 * {}:每一个子弹的公共数据
 * r:排布为圆形的半径
 * speed:所有子弹整体移动的速度
 * roSpeed:每个子弹在移动时沿着圆形旋转的(角)速度,写0.05-1之间的数据比较合适。
 * number:子弹的数量
 * initRotation:所有子弹整体移动的方向
 * x/y:坐标(此处无法使用G和GR)
 *
 * 例如:
 * QJ.BL.Shooter_C({},48,4,0.25,8,"M[]","P[]","P[]") 
 *
 * ***注意,此指令中默认的子弹图像Img为"dart"。若想修改请在{}中添加Img参数。
 *
 * ================================================================
 * 13.朝一个方向发射多个子弹,多个子弹在发射点附近排布为正多边形,整体朝一个方向发射。
 * QJ.BL.Shooter_P({},r,speed,roSpeed,number,initRotation,x,y,edgeNum) 
 * {}:每一个子弹的公共数据
 * r:正多边形的半径(多边形中心与多边形上任意一顶点的连线)
 * speed:所有子弹整体移动的速度
 * roSpeed:每个子弹在移动时沿着圆形旋转的(角)速度,写0.05-1之间的数据比较合适
 * number:多边形每条边上的子弹数(包括顶点),此值应大于等于2,且尽量写成奇数,写偶数效果可能不佳
 * initRotation:所有子弹整体移动的方向
 * x/y:坐标(此处无法使用G和GR)
 * edgeNum:多边形的边数,注意,边数应为大于等于2的正整数
 *
 * 例如:
 * 正三角形:QJ.BL.Shooter_P({},48,4,0.25,3,"M[]","P[]","P[]",3) 
 * 正方形形:QJ.BL.Shooter_P({},48,4,0.25,3,"M[]","P[]","P[]",4) 
 * 正五边形:QJ.BL.Shooter_P({},48,4,0.25,3,"M[]","P[]","P[]",5) 
 * ***注意,此指令中默认的子弹图像Img也为"dart"。若想修改请在{}中添加Img参数。
 *
 * ================================================================
 * 14.朝一个方向发射激光,激光会反弹,对接触到的敌人造成伤害。
 *
 * QJ.BL.Laser({})
 * {}中可以写的数据有:
 * name:默认为""。此值会被记录,可以使用QJ.BL.deleteLaser(name);来删除指定激光。
 * initialRotation:默认为"M[]"。发射角度,在RotationAuto写-1时,激光的角度会不断读取initialRotation的值。
 *      注意,此项内PD[]和D[]不能同时出现,只能用一个（不过这两个几乎不可能合起来用吧ORZ）。
 * RotationAuto:默认为-1。旋转速度,写下面指定的数字。
 *          写-1:不断修正。
 *          写0:角度不变。
 *          写1-719的正整数:减去360后为固定旋转速度。例如写360时其实是不旋转,写361是旋转1度每帧,写359是旋转-1度每帧。
 * x/y:默认为"P[]"。发射坐标,会自动进行变化。
 *     "M[]"代表鼠标的X/Y位置。
 *     "P[]"代表玩家的X/Y位置。
 *     "E[0]"代表本事件。
 *     "E[事件id]"代表指定id的事件。
 *     (此处无法使用G和GR)
 * z:默认为"C[]"。
 * Action:默认为[]。与其他指令中的Action一样。
 * Regions:默认为[]。与其他指令中的Regions一样。
 * Terrains:默认为[]。与其他指令中的Terrains一样。
 * Target:默认为[]。与其他指令中的Target一样。
 * Img:默认为"laser1"。
 * ImgPoint:默认为"laser1Point"。转折点的图片。
 * DeadCount:默认为10。消失时所需时间。
 * Opacity*:默认为255。与其他指令中的Opacity一样。
 * Width*:默认为12。激光判定宽度
 * AtkWait:默认为30。每两次攻击的间隔
 * ReBound:默认为2。最大反弹次数
 * Tone:色调。
 * Blend:覆盖颜色。
 * Hex:色相。
 * Max:默认为120。最大存在时间。
 *     -1:永远存在,只有使用通用的删除弹幕指令或者在指定当前子弹的Name属性后使用QJ.BL.deleteLaser(Name);才可以删除。
 *     "S[id,true/false]":设置当某开关打开/关闭时子弹消失。
 *     "SS[EventId,A/B/C/D,true/false]":设置当某事件的独立开关开关开启/关闭时取消。
 *         EventId写0时代表本事件id,只在此指令是在事件中执行时才有效。
 *     "T[内容]":执行内容,获取其结果作为布尔值来判断,结果为true时子弹消失。
 * ScaleX*:图片的横向比率。此处没有纵向比率。
 * MaxLength*:单条激光的最大长度,默认为960（像素）。
 * noPassDo:默认为false。在不可通行图块也触发碰撞效果。
 * UpdateJS:默认为""。string，每帧执行。
 * blendMode:合成方式，默认为0。
 * clearProjectile:默认为""。在其他子弹碰到此子弹时其他子弹将会被消除。
 * lineExpandMode:默认为false。写true时激光的延长方式变为纵向重复。
 *                 写成true时的缺点：参数Tone，Blend无效 消耗资源增多。
 * lineExpandScrollSpeed:默认为0。
 *                 当lineExpandMode为true时，写此项可以使激光在直线方向上滚动。速度一般写0-3之内的数字。
 *
 *
 * 例如（可直接使用）:QJ.BL.Laser({});
 * 
 * 若想手动消除激光可以使用:
 * QJ.BL.deleteLaser(name);
 * 来消除某个事件/玩家身上绑定的激光。
 *
 * 激光一般不会被敌人阻挡，但要做某些特别的能阻挡障碍物的物品时，可以在注释中写<laserObstacle>。
 * 这样此事件 所在的那一格(注意，是那一格，不是事件本身) 就能反射/阻挡激光。注意！若行走图因文件
 * 名内无"!"而上浮，同时右方插件参数中的"行走图自动上浮"为true,则激光很可能打不到该事件！
 *
 * ================================================================
 * 15.向四周发射物品,玩家触碰物品后即可获得此物品。
 * 此指令发射一个可以被当做“可捡取物品”的子弹。
 * ***注意！此指令适配MOG_TreasurePopup.js插件***
 * QJ.BL.Shooter_Gain({},type,id,num)
 * {}附加参数
 * type:获得物品的类型,写0或"item"是物品,写1或"weapon"是武器,写2或"armor"是护甲,写3时是金钱
 * id:当type是0或1或2时此数值写获得的物品/武器/护甲的id编号,此时Img主动变为该物品的图标。
 *     当type是3时,玩家获得的是金钱,id指金钱的图标,用于指定Img
 * num:获得个数
 *
 * 例如:
 * 发射获得5个id为2的物品的弹幕QJ.BL.Shooter_Gain({},0,2,5)
 * 发射获得6个id为6的武器的弹幕QJ.BL.Shooter_Gain({},1,6,6)
 * 发射获得2个id为7的护甲的弹幕QJ.BL.Shooter_Gain({},2,7,2)
 * 发射获得100金钱,且图像为5号图标的弹幕QJ.BL.Shooter_Gain({},3,5,100)
 *
 * ================================================================
 * 16.以两个点为描点,在这两个描点之间显示一张图片。然后在这两点间进行攻击判定。
 * QJ.BL.TwoPoint(x1,y1,x2,y2,{});
 * x1,y1,x2,y2:x1和y1为原点坐标,x2和y2是终点坐标。
 *     "M[]"代表鼠标的X/Y位置。
 *     "P[]"代表玩家的X/Y位置。
 *     "E[0]"代表本事件。
 *     "E[事件id]"代表指定id的事件。
 *     "G[事件集合编号,orginX,orginY]"读取某个事件集合中距离点(orginX,orginY)最近的事件的X/Y位置。
 *         orginX/orginY即可写数字,也可写M[]/P[]/E[0]/E[事件id]。（不可再嵌套,若想做特殊的效果请联系我）
 *     "GR[事件集合编号]"读取某个事件集合中随机事件的X/Y位置。
 *          如果x和y中都有GR的话,那么x和y中GR所选取的随机事件将相同。
 *      (此处的G和GR在读取一次后便会自动修改为对应的E[事件id],以便让每次更新坐标时仍旧指向同一个事件。)
 * {}中可以写:
 * name:默认为""。此值会被记录,可以使用QJ.BL.deleteTwoPoint(name);来删除指定连线。
 * Img:图片名
 * ImgPoint:起止点的图像。默认为"",即不在起止点显示图像。
 * lineMode:默认为"L[]"。
 *     "L[]":图片为一条竖着的直线，此项将会连接两个点。
 *     "C[angle]"或
 *     "C[angle,connect offset]"或
 *     "C[angle,connect offset,accuracy class]":
 *          在两点之间绘制一条贝塞尔曲线，然后使用图片作为该贝塞尔曲线的纹理。
 *          angle：计算二次贝塞尔曲线的一个控制点相对于起始点与终止点之间的连线的偏移角度，起止点的连线小于180度
 *                 时减偏移角度，大于180度时加偏移角度，以保证生成的直线一直朝上。
 *                 控制点在以起止点的连线为直径的圆上。
 *                 建议值为30~60（度）。
 *          connect offset：两个连接点之间的偏移，使用此值可减缓两个纹理间的缝隙带来的违和感，单位是像素，建议写
 *                 1到5的数字。默认值为0。
 *          accuracy class：一段纹理的绘制距离倍率。默认情况下根据二次贝塞尔曲线的参数方程的t值进行等时取值来绘制
 *                  不同段的纹理。使用此值可减少绘制纹理的间隔，从而使绘制更加精准。建议写0.4到1。默认值为1。
 *     "B[seed]"或
 *     "B[seed,offset]"或
 *     "B[seed,offset,minStep,maxStep]"或
 *     "B[seed,offset,minStep,maxStep,disturbance]":
 *          在两点之间绘制一条折线。
 *          折线的实现原理是：在连接起止点的直线上每隔一段距离（在minStep和maxStep之间）选择一个点，使此点沿着连接起止点
 *          的直线的垂线方向随机移动offset-offset/2像素的距离。
 *          seed：默认为9。大于0小于999999的整数，一个伪随机数种子。此值决定了距离的随机方法与垂线的随机方法。
 *                此值可以写动态随机数来做动态效果。例如：
 *                0|1~3|2~3|3~3|4~3|3~3|2~3|1
 *          offset：默认为100。大于0小于100的整数，具体的含义在上面的说明中。
 *          minStep,maxStep：默认为20和40。大于10小于100的整数，其中maxStep须得大于minStep。具体的含义在上面的说明中。
 *          disturbance:转折点的轻微扰动范围，建议写5-20，默认为10。
 * Max:默认为120。最大存在时间。
 *     -1:永远存在,只有使用通用的删除弹幕指令或者在指定当前子弹的Name属性后使用QJ.BL.deleteTwoPoint(Name);才可以删除。
 *     "S[id,true/false]":设置当某开关打开/关闭时子弹消失。
 *     "SS[EventId,A/B/C/D,true/false]":设置当某事件的独立开关开关开启/关闭时取消。
 *         EventId写0时代表本事件id,只在此指令是在事件中执行时才有效。
 *     "T[内容]":执行内容,获取其结果作为布尔值来判断,结果为true时子弹消失。
 * DeadCount:淡出时间
 * Opacity*:不透明度
 * ScaleX*:X放大率（无scaleY）
 * Tone:色调。
 * Blend:覆盖颜色。
 * Hex:色相。
 * Action:默认为[]。与其他指令中的Action一样。
 * Target:默认为[]。与其他指令中的Target一样。
 * Width*:默认为24。判定宽度
 * AtkWait:默认为30。每两次攻击的间隔
 * ExtraRotation:在判定基础上添加的额外旋转角度,以(x1,y1)为旋转中心。
 * AtkRange:默认为0。此值大于0时，width无效，不会沿着图片攻击。反而是在点(x2,y2)处进行一次圆形的攻击判定，
 *      判定半径即为此值。
 * blendMode:合成方式，默认为0。
 * clearProjectile:默认为""。在其他子弹碰到此子弹时其他子弹将会被消除。
 *
 * 若想手动消除可以使用:
 * QJ.BL.deleteTwoPoint(name);
 * 来消除某个事件/玩家身上绑定的激光。
 *
 * 
 * ================================================================
 * 17.使事件/玩家不断产生残影。
 *      QJ.BL.addShadow(character,{},time,delta)
 * time:产生阴影的次数或者条件。默认为60。
 *      还可以写:
 *      "S[id,true/false]"设置当某开关开启/关闭时取消。
 *      "SS[A/B/C/D,true/false]"设置当此事件的独立开关开关开启/关闭时取消。
 *          此指令只有在character为事件时才有效。
 *      "T[内容]"执行内容,获取其结果作为布尔值来判断。
 * delta:两次产生残影的等待时间。默认为1。单位为帧。
 * ================================================================
 * 18.直接执行文字预设中的指令。
 *      QJ.BL.quickOrder(id)
 * 假如有好多事件的弹幕发射指令一样,要改的话需要一个一个改会很麻烦。这时使用这个指令就可以直接统一控制。
 * ================================================================
 * 19.在一定角度内随机发射随机大小的子弹。
 *      QJ.BL.Shooter_FlameThrower({},minScale,maxScale,offsetDir,num)
 * {}:子弹的有关设置。
 * minScale/maxScale:子弹的最大和最小放大率。
 * offsetDir:子弹沿着{}中指定的initialRotation初始角度的最大偏移大小,比如initialRotation写90,offsetDir写10的话,
 *      子弹就会在80-100度内随机发射。
 * num:一次性发射子弹的数量。
 * ================================================================
 * 三.事件页第一行的注释中可以写:
 * ================================================================
 * 1.<BoxType:刚体类型>单独修改该事件的碰撞体积。
 * ================================================================
 * 2.<BoxOffset:x,y>单独修改该事件的碰撞体积中心。
 * ================================================================
 * 3.<Group:"该事件所属的事件集合的编号">
 *   这样可以将事件归类。若某事件的被触发事件页第一行没有注释,但别的未被触发的事件页的第一行有此注释,此
 *   事件同样不会被攻击到。这样可以配合着做“敌人被击败后不会再被攻击到”的效果。
 *   例如地图上有一些事件:这些事件的第一个事件页的第一行为注释,且注释中写着<Group:"enemy">
 *   且玩家发射的子弹的Target中写["G[enemy]"],那么此子弹只能攻击到上方所说的写着<Group:"enemy">的事件。
 *   若InitialRotation写成"G[enemy]"那么此子弹发射时自动对准写着<Group:"enemy">的那些事件中距离此子弹
 *   发射点最近的事件。
 * ================================================================
 * 四:额外脚本指令
 * ================================================================
 * 1.修改事件默认碰撞体积和偏移:
 *      QJ.BL.setDefaultEventBox(CollisionBox,OffsetX,OffsetY)
 *      CollisionBox:默认事件的碰撞体积,我们规划一个图形用来代表事件的碰撞体积。
 *          "C[半径]"（Circle）以事件所在格子的正中心为原点,画一个圆代表事件的碰撞体积。
 *          "R[宽,高]"（Rectangle）以一个长方形为碰撞形状。
 *      OffsetX和OffsetY:在此插件中,所说的“事件所在位置”指事件所在格子的正中间,也就是事件的碰撞体积中心。
 *          想要修改这个原点位置,可以使用此指令。若想单独修改某一事件的相关属性,则请往下看。
 * ================================================================
 * 2.修改玩家的默认碰撞体积和偏移:
 *      QJ.BL.setPlayerBox(CollisionBox,OffsetX,OffsetY)
 * ================================================================
 *
 *
 *
 *
 * @param ======玩家预设======
 * @default
 *
 * @param playerInitBox
 * @type text
 * @text 玩家预设刚体
 * @desc 建议写R[48,48]或者C[24]
 * @default R[48,48]
 * @parent ======玩家预设======
 *
 * @param playerInitBoxOffsetX
 * @type text
 * @text 玩家预设刚体X偏移
 * @desc 0
 * @default 0
 * @parent ======玩家预设======
 *
 * @param playerInitBoxOffsetY
 * @type text
 * @text 玩家预设刚体Y偏移
 * @desc 0
 * @default 0
 * @parent ======玩家预设======
 *
 * @param ======事件预设======
 * @default
 *
 * @param eventInitBox
 * @type text
 * @text 事件预设刚体
 * @desc 建议写R[48,48]或者C[24]
 * @default R[48,48]
 * @parent ======事件预设======
 *
 * @param eventInitBoxOffsetX
 * @type text
 * @text 事件预设刚体X偏移
 * @desc 0
 * @default 0
 * @parent ======事件预设======
 *
 * @param eventInitBoxOffsetY
 * @type text
 * @text 事件预设刚体Y偏移
 * @desc 0
 * @default 0
 * @parent ======事件预设======
 *
 * @param ======杂项======
 * @default
 *
 * @param forBidDestination
 * @type boolean
 * @text 取消掉点击移动
 * @desc 初始时是否取消掉点击移动，注意，取消掉后也无法再直接与事件进行互动，但可以用指令恢复。
 * @default true
 * @parent ======杂项======
 *
 * @param showWarn
 * @type boolean
 * @text 是否显示警告信息
 * @desc 是否显示警告信息,调试的时候请打开
 * @default true
 * @parent ======杂项======
 *
 * @param maxbullet
 * @type number
 * @min 1
 * @text 最大子弹数
 * @desc 场上存在的子弹越多，越容易卡。
 * @default 100
 * @parent ======杂项======
 *
 * @param offsetGY
 * @type boolean
 * @text 行走图自动上浮
 * @desc 是否让碰撞体随着角色行走图向上浮动6个像素。
 * @default false
 * @parent ======杂项======
 *
 * @param ======预载预设======
 * @default
 *
 * @param reserveImg
 * @type []
 * @text 预载子弹名称
 * @desc 预载子弹的图片名，同类型多个时可在一行内用|分隔。
 * @default []
 * @parent ======预载预设======
 *
 * @param preset
 * @type struct<persetdata>[]
 * @text 预设指令
 * @desc 可以使用QJ.BL.Quick(预设编号,{})来直接调用
 * @default []
 * @parent ======预载预设======
 *
 * @param presetText
 * @type struct<persetdataType>[]
 * @text 文字预设指令
 * @desc 在子弹中的UpdateQT,MoveQT,DeadQT中使用。
 * @default []
 * @parent ======预载预设======
 *
 * @param ======显示碰撞体积======
 * @default
 *
 * @param canShowBox
 * @type boolean
 * @text 是否可显示碰撞体积
 * @desc 是否可显示碰撞体积，这里写false时按F10也无用。可以增加些许性能。
 * @default true
 * @parent ======显示碰撞体积======
 *
 * @param showBox
 * @type boolean
 * @text 是否默认显示碰撞体积
 * @desc 是否默认显示碰撞体积,游戏运行时可按下F10显示/不显示碰撞体积。
 * @default false
 * @parent ======显示碰撞体积======
 *
 * @param ======根据帧率显示特效======
 * @default
 *
 * @param effectAutoFPS
 * @type boolean
 * @text 启用
 * @desc 启用
 * @default false
 * @parent ======根据帧率显示特效======
 *
 * @param tooLowFPS
 * @type number
 * @min 1
 * @max 60
 * @text 低FPS标准
 * @desc 低FPS标准
 * @default 30
 * @parent ======根据帧率显示特效======
 *
 * @param ======自动更新======
 * @default
 *
 * @param synAuto
 * @type boolean
 * @text 自动更新
 * @desc 自动更新，在制作工程时建议开启，在正式发布游戏时建议关闭。
 * @default false
 * @parent ======自动更新======
 *
 * @param directSyn
 * @type boolean
 * @text 主动更新
 * @on 直接自主更新
 * @off 单纯提示更新
 * @desc 可以选择是直接自主更新，还是仅仅提示您需要更新
 * @default true
 * @parent ======自动更新======
 *
*/
/*~struct~persetdataType:
 *
 * @param name
 * @type text
 * @text 此预设的编号
 * @desc 此预设的编号
 * @default 1
 *
 * @param content1
 * @type note
 * @text 内容1
 * @desc 内容1
 * @default 
 *
 * @param content2
 * @type note
 * @text 内容2
 * @desc 内容2
 * @default 
 *
 * @param content3
 * @type note
 * @text 内容3
 * @desc 内容3
 * @default 
 *
*/
/*~struct~persetdata:
 *
 * @param name
 * @type text
 * @text 此预设的编号
 * @desc 此预设的编号
 * @default 1
 *
 * @param initialRotation
 * @type combo
 * @text 初始朝向
 * @desc 初始朝向
 * @default PD[]
 * @option PD[]
 * @option M[]
 * @option D[]
 * @option P[]
 * @option E[事件id]
 * @option EV[变量id]
 * @option X[数字]Y[数字]
 * @option XM[数字]YM[数字]
 * @option G[事件集合编号]
 * @option N[特殊编号]
 *
 * @param x
 * @type combo
 * @text x
 * @desc x
 * @default P[]
 * @option P[]
 * @option E[0]
 * @option E[事件id]
 *
 * @param y
 * @type combo
 * @text y
 * @desc y
 * @default P[]
 * @option P[]
 * @option E[0]
 * @option E[事件id]
 *
 * @param z
 * @type combo
 * @text z
 * @desc z
 * @default C[]
 * @option T[]
 * @option M[]
 * @option C[]
 * @option P[]
 *
 * @param scaleX
 * @type text
 * @text x放大率
 * @desc x放大率
 * @default 100
 *
 * @param scaleY
 * @type text
 * @text y放大率
 * @desc y放大率
 * @default 100
 *
 * @param MoveType
 * @type combo
 * @text 移动类型
 * @desc 移动类型
 * @default S[]
 * @option TP[最小转角]
 * @option TE[最小转角,事件id]
 * @option TEV[最小转角,变量id]
 * @option TG[最小转角,事件集合编号]
 * @option TN[最小转角,特殊编号]
 * @option QP[一倍宽度,发射角度,一倍时间,次数]
 * @option B[指定id,朝下x偏移,朝下y偏移,朝左x偏移,朝左y偏移,朝右x偏移,朝右y偏移,朝上x偏移,朝上y偏移]
 * @option F[函数]
 *
 * @param rTRotation
 * @type text
 * @text 特殊的旋转角度附加
 * @desc 特殊的旋转角度附加
 * @default 
 *
 * @param bTRotation
 * @type text
 * @text 特殊的旋转角度2附加
 * @desc 特殊的旋转角度2附加
 * @default 
 *
 * @param Regions
 * @type text
 * @text 消失区域id的列表
 * @desc 消失区域id的列表
 * @default []
 *
 * @param Terrains
 * @type text
 * @text 消失地形id的列表
 * @desc 消失地形id的列表
 * @default []
 *
 * @param Target
 * @type text
 * @text 目标列表
 * @desc 目标列表"E[事件id]" "G[事件列表的id]" "EV[数字]" "P[]" "Nobi[T]"
 * @default []
 *
 * @param Pierce
 * @type number
 * @text 穿透次数
 * @desc 穿透次数
 * @default 0
 *
 * @param Img
 * @type file
 * @dir img/bullets
 * @text 图片文件名
 * @desc 图片文件名
 * @default 
 *
 * @param Anim
 * @type animation
 * @text 动画id
 * @desc 动画id
 * @default 0
 *
 * @param DeadCount
 * @type number
 * @text 淡出时间
 * @desc 淡出时间
 * @default 0
 *
 * @param DeadScale
 * @type number
 * @text 淡出放大倍数
 * @desc 淡出放大倍数
 * @default 100
 *
 * @param Speed
 * @type text
 * @text 速度
 * @desc 速度
 * @default 12
 *
 * @param Max
 * @type text
 * @text 最大存在时间
 * @desc 最大存在时间
 * @default 120
 *
 * @param RotationAuto
 * @type text
 * @text 图像旋转速度
 * @desc 图像旋转速度
 * @default -1
 *
 * @param Action
 * @type text
 * @text 行动列表
 * @desc 行动列表"S[id,value]" "SS[id,value]" "E[]" "C[公共事件id,传参1,传参2……]"  "CP[id]" "T[语句]"
 * @default []
 *
 * @param CollisionBox
 * @type text
 * @text 碰撞体积
 * @desc 碰撞体积
 * @default R[4,4]
 *
 * @param Tone
 * @type text
 * @text 色调
 * @desc 色调
 * @default [0,0,0,0]
 *
 * @param Blend
 * @type text
 * @text 覆盖颜色
 * @desc 覆盖颜色
 * @default [0,0,0,0]
 *
 * @param Hex
 * @type text
 * @text 色相
 * @desc 色相
 * @default 0
 *
 * @param Opacity
 * @type text
 * @text 不透明度
 * @desc 不透明度
 * @default 255
 *
 * @param AfterImage
 * @type text
 * @text 残影
 * @desc 残影 [颜色,初始不透明度,最大存在时间,宽度]
 * @default []
 *
 * @param Light
 * @type text
 * @text 光效
 * @desc 光效
 * @default {}
 *
 * @param Particles
 * @type struct<particles>[]
 * @text 粒子效果
 * @desc 粒子效果
 * @default []
 *
 * @param AtkRange
 * @type number
 * @text 攻击范围
 * @desc 攻击范围
 * @default 0
 *
 * @param WaitBaseOnSpeed
 * @type text
 * @text 特殊数值
 * @desc 特殊数值
 * @default -2
 *
 * @param DeadAction
 * @type boolean
 * @text 死亡行动
 * @desc 死亡行动
 * @default false
 *
 * @param PierceAction
 * @type boolean
 * @text 穿透行动
 * @desc 穿透行动
 * @default false
 *
 * @param NoCollisionAction
 * @type boolean
 * @text 消失行动
 * @desc 消失行动
 * @default false
 *
 * @param DeadAnim
 * @type boolean
 * @text 死亡动画
 * @desc 死亡动画
 * @default true
 *
 * @param PierceAnim
 * @type boolean
 * @text 穿透动画
 * @desc 穿透动画
 * @default false
 *
 * @param NoCollisionAnim
 * @type boolean
 * @text 消失动画
 * @desc 消失动画
 * @default false
 *
 * @param ReBound
 * @type boolean
 * @text 反弹
 * @desc 反弹
 * @default false
 *
 * @param AnchorX
 * @type text
 * @text x描点
 * @desc x描点
 * @default 0.5
 *
 * @param AnchorY
 * @type text
 * @text y描点
 * @desc y描点
 * @default 0.5
 *
 * @param LMD
 * @type boolean
 * @text 自动消除
 * @desc 自动消除
 * @default true
 *
 * @param Bit
 * @type boolean
 * @text 是否禁止碰撞检测
 * @desc 是否禁止碰撞检测
 * @default false
 *
 * @param UpdateJS
 * @type Note
 * @text 帧指令
 * @desc 具体请查看说明
 * @default 
 *
 * @param MoveJS
 * @type Note
 * @text 定时指令
 * @desc 具体请查看说明
 * @default 
 *
 * @param DeadJS
 * @type Note
 * @text 死亡指令
 * @desc 具体请查看说明
 * @default 
 *
 * @param UpdateQT
 * @type Text
 * @text 帧文字预设指令
 * @desc 具体请查看说明
 * @default 
 *
 * @param MoveQT
 * @type Text
 * @text 定时文字预设指令
 * @desc 具体请查看说明
 * @default 
 *
 * @param DeadQT
 * @type Text
 * @text 死亡文字预设指令
 * @desc 具体请查看说明
 * @default
 *
 * @param Name
 * @type Text
 * @text 弹幕名字
 * @desc 弹幕指定一个名字，然后可以使用QJ.BL.deleteBullet(Name);来直接删除指定名字的弹幕。
 * @default 
 *
 * @param noPassDo
 * @type boolean
 * @text 不可通行图块
 * @desc 不可通行图块触发碰撞效果
 * @default false
 *
 * @param blendMode
 * @type select
 * @option 普通
 * @value 0
 * @option 加法
 * @value 1
 * @option 乘法
 * @value 2
 * @option 画面
 * @value 3
 * @text 合成方式
 * @desc 合成方式
 * @default 0
 *
 * @param clearProjectile
 * @type Text
 * @text 清除其余子弹
 * @desc 清除其余子弹
 * @default 
 *
 * @param cancalEachOther
 * @type boolean
 * @text 子弹互相消除
 * @desc 子弹互相消除
 * @default true
 *
 * @param onScreen
 * @type boolean
 * @text 是否固定于屏幕
 * @desc 是否固定于屏幕
 * @default false
 *
*/
/*~struct~particles:
 * @param img
 * @type text
 * @text 图像
 * @desc 图像
 * @default 
 *
 * @param offsetX
 * @type number
 * @text 偏移
 * @desc 偏移
 * @default 0
 *
 * @param offsetY
 * @type text
 * @text number
 * @desc 偏移
 * @default 0
 *
 * @param dir
 * @type text
 * @text 方向
 * @desc 方向
 * @default Math.PI
 *
 * @param dirOffset
 * @type text
 * @text 方向偏移
 * @desc 方向偏移
 * @default Math.PI/6
 *
 * @param max
 * @type number
 * @text 最大存在时间
 * @desc 最大存在时间
 * @default 120
 *
 * @param deadCount
 * @type number
 * @text 淡出时间
 * @desc 淡出时间
 * @default 10
 *
 * @param opacityMin
 * @type text
 * @text 最小不透明度
 * @desc 最小不透明度
 * @default 0.5
 *
 * @param opacityMax
 * @type text
 * @text 最大不透明度
 * @desc 最大不透明度
 * @default 1
 *
 * @param scaleMin
 * @type text
 * @text 最小放大率
 * @desc 最小放大率
 * @default 0.5
 *
 * @param scaleMax
 * @type text
 * @text 最大放大率
 * @desc 最大放大率
 * @default 1.5
 *
 * @param moveType
 * @type text
 * @text 移动类型函数
 * @desc 移动类型函数
 * @default -8*t;0
 *
 * @param wait
 * @type number
 * @text 发射间隔
 * @desc 发射间隔
 * @default 2
 *
*/
//=============================================================================
//SAT.js
//=============================================================================
/*!
 * SAT.js - v0.9.0
 * License MIT
 */
if (!SATVectorMV) {
    function SATVectorMV(x, y) {  this['x'] = x || 0;  this['y'] = y || 0;}SATVectorMV.prototype.copy = function (other) {  this['x'] = other['x'];  this['y'] = other['y'];  return this;};SATVectorMV.prototype.clone = function () {  return new SATVectorMV(this['x'], this['y']);};SATVectorMV.prototype.perp = function () {  var x = this['x'];  this['x'] = this['y'];  this['y'] = -x;  return this;};SATVectorMV.prototype.rotate = function (angle) {  var x = this['x'];  var y = this['y'];  this['x'] = x * Math.cos(angle) - y * Math.sin(angle);  this['y'] = x * Math.sin(angle) + y * Math.cos(angle);  return this;};SATVectorMV.prototype.reverse = function () {  this['x'] = -this['x'];  this['y'] = -this['y'];  return this;};SATVectorMV.prototype.normalize = function () {  var d = this.len();  if (d > 0) {    this['x'] = this['x'] / d;    this['y'] = this['y'] / d;  }  return this;};SATVectorMV.prototype.add = function (other) {  this['x'] += other['x'];  this['y'] += other['y'];  return this;};SATVectorMV.prototype.sub = function (other) {  this['x'] -= other['x'];  this['y'] -= other['y'];  return this;};SATVectorMV.prototype.scale = function (x, y) {  this['x'] *= x;  this['y'] *= typeof y != 'undefined' ? y : x;  return this;};SATVectorMV.prototype.project = function (other) {  var amt = this.dot(other) / other.len2();  this['x'] = amt * other['x'];  this['y'] = amt * other['y'];  return this;};SATVectorMV.prototype.projectN = function (other) {  var amt = this.dot(other);  this['x'] = amt * other['x'];  this['y'] = amt * other['y'];  return this;};SATVectorMV.prototype.reflect = function (axis) {  var x = this['x'];  var y = this['y'];  this.project(axis).scale(2);  this['x'] -= x;  this['y'] -= y;  return this;};SATVectorMV.prototype.reflectN = function (axis) {  var x = this['x'];  var y = this['y'];  this.projectN(axis).scale(2);  this['x'] -= x;  this['y'] -= y;  return this;};SATVectorMV.prototype.dot = function (other) {  return this['x'] * other['x'] + this['y'] * other['y'];};SATVectorMV.prototype.len2 = function () {  return this.dot(this);};SATVectorMV.prototype.len = function () {  return Math.sqrt(this.len2());};function SATCircle(pos, r) {  this['pos'] = pos || new SATVectorMV();  this['r'] = r || 0;  this['offset'] = new SATVectorMV();}SATCircle.prototype.getAABBAsBox = function () {  var r = this['r'];  var corner = this['pos'].clone().add(this['offset']).sub(new SATVectorMV(r, r));  return new SATBox(corner, r * 2, r * 2);};SATCircle.prototype.getAABB = function () {  return this.getAABBAsBox().toPolygon();};SATCircle.prototype.setOffset = function (offset) {  this['offset'] = offset;  return this;};function SATPolygon(pos, points) {  this['pos'] = pos || new SATVectorMV();  this['angle'] = 0;  this['offset'] = new SATVectorMV();  this.setPoints(points || []);}SATPolygon.prototype.setPoints = function (points) {  var lengthChanged = !this['points'] || this['points'].length !== points.length;  if (lengthChanged) {    var i;    var calcPoints = this['calcPoints'] = [];    var edges = this['edges'] = [];    var normals = this['normals'] = [];    for (i = 0; i < points.length; i++) {      var p1 = points[i];      var p2 = i < points.length - 1 ? points[i + 1] : points[0];      if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {        points.splice(i, 1);        i -= 1;        continue;      }      calcPoints.push(new SATVectorMV());      edges.push(new SATVectorMV());      normals.push(new SATVectorMV());    }  }  this['points'] = points;  this._recalc();  return this;};SATPolygon.prototype.setAngle = function (angle) {  this['angle'] = angle;  this._recalc();  return this;};SATPolygon.prototype.setOffset = function (offset) {  this['offset'] = offset;  this._recalc();  return this;};SATPolygon.prototype.rotate = function (angle) {  var points = this['points'];  var len = points.length;  for (var i = 0; i < len; i++) {    points[i].rotate(angle);  }  this._recalc();  return this;};SATPolygon.prototype.translate = function (x, y) {  var points = this['points'];  var len = points.length;  for (var i = 0; i < len; i++) {    points[i]['x'] += x;    points[i]['y'] += y;  }  this._recalc();  return this;};SATPolygon.prototype._recalc = function () {  var calcPoints = this['calcPoints'];  var edges = this['edges'];  var normals = this['normals'];  var points = this['points'];  var offset = this['offset'];  var angle = this['angle'];  var len = points.length;  var i;  for (i = 0; i < len; i++) {    var calcPoint = calcPoints[i].copy(points[i]);    calcPoint['x'] += offset['x'];    calcPoint['y'] += offset['y'];    if (angle !== 0) {      calcPoint.rotate(angle);    }  }  for (i = 0; i < len; i++) {    var p1 = calcPoints[i];    var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];    var e = edges[i].copy(p2).sub(p1);    normals[i].copy(e).perp().normalize();  }  return this;};SATPolygon.prototype.getAABBAsBox = function () {  var points = this['calcPoints'];  var len = points.length;  var xMin = points[0]['x'];  var yMin = points[0]['y'];  var xMax = points[0]['x'];  var yMax = points[0]['y'];  for (var i = 1; i < len; i++) {    var point = points[i];    if (point['x'] < xMin) {      xMin = point['x'];    }    else if (point['x'] > xMax) {      xMax = point['x'];    }    if (point['y'] < yMin) {      yMin = point['y'];    }    else if (point['y'] > yMax) {      yMax = point['y'];    }  }  return new SATBox(this['pos'].clone().add(new SATVectorMV(xMin, yMin)), xMax - xMin, yMax - yMin);};SATPolygon.prototype.getAABB = function () {  return this.getAABBAsBox().toPolygon();};SATPolygon.prototype.getCentroid = function () {  var points = this['calcPoints'];  var len = points.length;  var cx = 0;  var cy = 0;  var ar = 0;  for (var i = 0; i < len; i++) {    var p1 = points[i];    var p2 = i === len - 1 ? points[0] : points[i + 1];    var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];    cx += (p1['x'] + p2['x']) * a;    cy += (p1['y'] + p2['y']) * a;    ar += a;  }  ar = ar * 3;  cx = cx / ar;  cy = cy / ar;  return new SATVectorMV(cx, cy);};function SATBox(pos, w, h) {  this['pos'] = pos || new SATVectorMV();  this['w'] = w || 0;  this['h'] = h || 0;}SATBox.prototype.toPolygon = function () {  var pos = this['pos'];  var w = this['w'];  var h = this['h'];  return new SATPolygon(new SATVectorMV(pos['x'], pos['y']), [    new SATVectorMV(), new SATVectorMV(w, 0),    new SATVectorMV(w, h), new SATVectorMV(0, h)  ]);};function SATResponse() {  this['a'] = null;  this['b'] = null;  this['overlapN'] = new SATVectorMV();  this['overlapV'] = new SATVectorMV();  this.clear();}SATResponse.prototype.clear = function () {  this['aInB'] = true;  this['bInA'] = true;  this['overlap'] = Number.MAX_VALUE;  return this;};var T_VECTORS = [];for (var i = 0; i < 10; i++) { T_VECTORS.push(new SATVectorMV()); }var T_ARRAYS = [];for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }var T_RESPONSE = new SATResponse();var TEST_POINT = new SATBox(new SATVectorMV(), 0.000001, 0.000001).toPolygon();function flattenPointsOn(points, normal, result) {  var min = Number.MAX_VALUE;  var max = -Number.MAX_VALUE;  var len = points.length;  for (var i = 0; i < len; i++) {    var dot = points[i].dot(normal);    if (dot < min) { min = dot; }    if (dot > max) { max = dot; }  }  result[0] = min; result[1] = max;}function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {  var rangeA = T_ARRAYS.pop();  var rangeB = T_ARRAYS.pop();  var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);  var projectedOffset = offsetV.dot(axis);  flattenPointsOn(aPoints, axis, rangeA);  flattenPointsOn(bPoints, axis, rangeB);  rangeB[0] += projectedOffset;  rangeB[1] += projectedOffset;  if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {    T_VECTORS.push(offsetV);    T_ARRAYS.push(rangeA);    T_ARRAYS.push(rangeB);    return true;  }  if (response) {    var overlap = 0;    if (rangeA[0] < rangeB[0]) {      response['aInB'] = false;      if (rangeA[1] < rangeB[1]) {        overlap = rangeA[1] - rangeB[0];        response['bInA'] = false;      } else {        var option1 = rangeA[1] - rangeB[0];        var option2 = rangeB[1] - rangeA[0];        overlap = option1 < option2 ? option1 : -option2;      }    } else {      response['bInA'] = false;      if (rangeA[1] > rangeB[1]) {        overlap = rangeA[0] - rangeB[1];        response['aInB'] = false;      } else {        var option1 = rangeA[1] - rangeB[0];        var option2 = rangeB[1] - rangeA[0];        overlap = option1 < option2 ? option1 : -option2;      }    }    var absOverlap = Math.abs(overlap);    if (absOverlap < response['overlap']) {      response['overlap'] = absOverlap;      response['overlapN'].copy(axis);      if (overlap < 0) {        response['overlapN'].reverse();      }    }  }  T_VECTORS.push(offsetV);  T_ARRAYS.push(rangeA);  T_ARRAYS.push(rangeB);  return false;}function voronoiRegion(line, point) {  var len2 = line.len2();  var dp = point.dot(line);  if (dp < 0) { return LEFT_VORONOI_REGION; }  else if (dp > len2) { return RIGHT_VORONOI_REGION; }  else { return MIDDLE_VORONOI_REGION; }}var LEFT_VORONOI_REGION = -1;var MIDDLE_VORONOI_REGION = 0;var RIGHT_VORONOI_REGION = 1;function pointInCircle(p, c) {  var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);  var radiusSq = c['r'] * c['r'];  var distanceSq = differenceV.len2();  T_VECTORS.push(differenceV);  return distanceSq <= radiusSq;}function pointInPolygon(p, poly) {  TEST_POINT['pos'].copy(p);  T_RESPONSE.clear();  var result = SATtestPolygonPolygon(TEST_POINT, poly, T_RESPONSE);  if (result) {    result = T_RESPONSE['aInB'];  }  return result;}function SATtestCircleCircle(a, b, response) {  var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);  var totalRadius = a['r'] + b['r'];  var totalRadiusSq = totalRadius * totalRadius;  var distanceSq = differenceV.len2();  if (distanceSq > totalRadiusSq) {    T_VECTORS.push(differenceV);    return false;  }  if (response) {    var dist = Math.sqrt(distanceSq);    response['a'] = a;    response['b'] = b;    response['overlap'] = totalRadius - dist;    response['overlapN'].copy(differenceV.normalize());    response['overlapV'].copy(differenceV).scale(response['overlap']);    response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];    response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];  }  T_VECTORS.push(differenceV);  return true;}function SATtestPolygonCircle(polygon, circle, response) {  var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);  var radius = circle['r'];  var radius2 = radius * radius;  var points = polygon['calcPoints'];  var len = points.length;  var edge = T_VECTORS.pop();  var point = T_VECTORS.pop();  for (var i = 0; i < len; i++) {    var next = i === len - 1 ? 0 : i + 1;    var prev = i === 0 ? len - 1 : i - 1;    var overlap = 0;    var overlapN = null;    edge.copy(polygon['edges'][i]);    point.copy(circlePos).sub(points[i]);    if (response && point.len2() > radius2) {      response['aInB'] = false;    }    var region = voronoiRegion(edge, point);    if (region === LEFT_VORONOI_REGION) {      edge.copy(polygon['edges'][prev]);      var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);      region = voronoiRegion(edge, point2);      if (region === RIGHT_VORONOI_REGION) {        var dist = point.len();        if (dist > radius) {          T_VECTORS.push(circlePos);          T_VECTORS.push(edge);          T_VECTORS.push(point);          T_VECTORS.push(point2);          return false;        } else if (response) {          response['bInA'] = false;          overlapN = point.normalize();          overlap = radius - dist;        }      }      T_VECTORS.push(point2);    } else if (region === RIGHT_VORONOI_REGION) {      edge.copy(polygon['edges'][next]);      point.copy(circlePos).sub(points[next]);      region = voronoiRegion(edge, point);      if (region === LEFT_VORONOI_REGION) {        var dist = point.len();        if (dist > radius) {          T_VECTORS.push(circlePos);          T_VECTORS.push(edge);          T_VECTORS.push(point);          return false;        } else if (response) {          response['bInA'] = false;          overlapN = point.normalize();          overlap = radius - dist;        }      }    } else {      var normal = edge.perp().normalize();      var dist = point.dot(normal);      var distAbs = Math.abs(dist);      if (dist > 0 && distAbs > radius) {        T_VECTORS.push(circlePos);        T_VECTORS.push(normal);        T_VECTORS.push(point);        return false;      } else if (response) {        overlapN = normal;        overlap = radius - dist;        if (dist >= 0 || overlap < 2 * radius) {          response['bInA'] = false;        }      }    }    if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {      response['overlap'] = overlap;      response['overlapN'].copy(overlapN);    }  }  if (response) {    response['a'] = polygon;    response['b'] = circle;    response['overlapV'].copy(response['overlapN']).scale(response['overlap']);  }  T_VECTORS.push(circlePos);  T_VECTORS.push(edge);  T_VECTORS.push(point);  return true;}function SATtestCirclePolygon(circle, polygon, response) {  var result = SATtestPolygonCircle(polygon, circle, response);  if (result && response) {    var a = response['a'];    var aInB = response['aInB'];    response['overlapN'].reverse();    response['overlapV'].reverse();    response['a'] = response['b'];    response['b'] = a;    response['aInB'] = response['bInA'];    response['bInA'] = aInB;  }  return result;}function SATtestPolygonPolygon(a, b, response) {  var aPoints = a['calcPoints'];  var aLen = aPoints.length;  var bPoints = b['calcPoints'];  var bLen = bPoints.length;  for (var i = 0; i < aLen; i++) {    if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {      return false;    }  }  for (var i = 0; i < bLen; i++) {    if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {      return false;    }  }  if (response) {    response['a'] = a;    response['b'] = b;    response['overlapV'].copy(response['overlapN']).scale(response['overlap']);  }  return true;}
}
//=============================================================================
//
//=============================================================================
var QJ = QJ || {};
QJ.BL = QJ.BL || {};
var Imported = Imported || {};
Imported.QJBullet = true;
//=============================================================================
//
//=============================================================================
var numberQJY = 0;
//=============================================================================
//
//=============================================================================
function Game_QJBullet() {
    this.initialize.apply(this, arguments);
}
function Game_QJLaser() {
    this.initialize.apply(this, arguments);
}
function Game_QJTwoPoint() {
    this.initialize.apply(this, arguments);
}
function Game_InterpreterForceQBCommonEvent() {
    this.initialize.apply(this, arguments);
}
function Game_InterpreterForceQBEvent() {
    this.initialize.apply(this, arguments);
}
function QJFrame() {
    this.initialize.apply(this, arguments);
}
//=============================================================================
//
//=============================================================================
(($ = {})=>{
//=============================================================================
//
//=============================================================================
var QJ = window.QJ;
//=============================================================================
//
//=============================================================================
const pluginName = "QJ-Bullet";
const parameters = PluginManager.parameters(pluginName);
const preset=eval(parameters['preset']) || [];
const presetText=eval(parameters['presetText']) || [];
const maxbullet=Number(parameters['maxbullet']) || 200;
const showWarn=eval(parameters['showWarn']) || true;
const reserveImg=eval(parameters['reserveImg']);
const PresetText = (()=>{
    let list = {};
    for (let i=0;i<presetText.length;i++) {
        let detail=JsonEx.parse(presetText[i]);
        let stringCon = eval(detail.content1);
        if (detail.content2.length>0) stringCon=stringCon+"+"+eval(detail.content2);
        if (detail.content3.length>0) stringCon=stringCon+"+"+eval(detail.content3);
        list[String(detail.name)] = eval("(function(){"+stringCon+"})");
    }
    return list;
})();
QJ.BL.PresetText = PresetText;
const Preset = (()=>{
    let list = {};
    for (let i=0;i<preset.length;i++) {
        let detail=JsonEx.parse(preset[i]);
        list[String(detail.name)] = {
            initialRotation:detail.initialRotation,
            x:(isNaN(Number(detail.x))?detail.x:Number(detail.x)),
            y:(isNaN(Number(detail.y))?detail.y:Number(detail.y)),
            z:detail.z,
            scaleX:(isNaN(Number(detail.scaleX))?detail.scaleX:Number(detail.scaleX)),
            scaleY:(isNaN(Number(detail.scaleY))?detail.scaleY:Number(detail.scaleY)),
            //======================================
            MoveType:detail.MoveType,
            Regions:eval(detail.Regions),
            Terrains:eval(detail.Terrains),
            Target:eval(detail.Target),
            Pierce:Number(detail.Pierce),
            //======================================
            Img:((Img)=>{
                let newImg;
                try{newImg=eval(Img);} catch(e) {newImg=Img;}
                return newImg;
            })(detail.Img),
            Anim:Number(detail.Anim),
            DeadCount:Number(detail.DeadCount),
            DeadScale:detail.DeadCount?Number(detail.DeadCount):100,
            Speed:(isNaN(Number(detail.Speed))?detail.Speed:Number(detail.Speed)),
            Max:(isNaN(Number(detail.Max))?detail.Max:Number(detail.Max)),
            RotationAuto:Number(detail.RotationAuto),
            //======================================
            Action:eval(detail.Action),
            CollisionBox:detail.CollisionBox,
            //======================================
            Tone:detail.Tone?eval(detail.Tone):[0,0,0,0],
            Blend:detail.Blend?eval(detail.Blend):[0,0,0,0],
            Hex:detail.Hex?eval(detail.Hex):0,
            Opacity:(isNaN(Number(detail.Opacity))?detail.Opacity:Number(detail.Opacity)),
            AfterImage:eval(detail.AfterImage),
            Light:eval(detail.Light),
            Particles:eval(detail.Particles),
            AtkRange:Number(detail.AtkRange),
            DeadAction:eval(detail.DeadAction),
            PierceAction:eval(detail.PierceAction),
            NoCollisionAction:eval(detail.NoCollisionAction),
            DeadAnim:eval(detail.DeadAnim),
            PierceAnim:eval(detail.PierceAnim),
            NoCollisionAnim:eval(detail.NoCollisionAnim),
            ReBound:eval(detail.ReBound),
            AnchorX:Number(detail.AnchorX),
            AnchorY:Number(detail.AnchorY),
            rTRotation:detail.rTRotation?detail.rTRotation:'',
            bTRotation:detail.bTRotation?detail.bTRotation:'',
            WaitBaseOnSpeed:(isNaN(Number(detail.WaitBaseOnSpeed))?detail.WaitBaseOnSpeed:Number(detail.WaitBaseOnSpeed)),
            LMD:eval(detail.LMD),
            Bit:eval(detail.Bit),
            UpdateJS:detail.UpdateJS,
            MoveJS:detail.MoveJS,
            DeadJS:detail.DeadJS,
            UpdateQT:detail.UpdateQT,
            MoveQT:detail.MoveQT,
            DeadQT:detail.DeadQT,
            Name:detail.Name,
            noPassDo:eval(detail.noPassDo),
            blendMode:detail.blendMode?Number(detail.blendMode):0,
            clearProjectile:detail.clearProjectile?detail.clearProjectile:"",
            cancalEachOther:detail.cancalEachOther?eval(detail.cancalEachOther):true,
            onScreen:detail.onScreen?eval(detail.onScreen):false
        }
    }
    //console.log(list);
    return list;
})();
const tileSize=48;
let QJBInter=null;
let forBidDestination=eval(parameters['forBidDestination']) || false;
let textureSave = {};
const offsetGY = eval(parameters['offsetGY']);
let showBox = eval(parameters['showBox']);
const canShowBox = eval(parameters['canShowBox']) || true;
//=================================
Input.keyMapper[121] = 'F10';
QJ.BL.sprite = null;
const effectAutoFPS = QJ.BL.effectAutoFPS = eval(parameters.effectAutoFPS) || false;
const tooLowFPS = QJ.BL.tooLowFPS = eval(parameters.tooLowFPS) || 30;
//=============================================================================
//
//=============================================================================
let mouseX=0,mouseY=0;
$.TouchInput__onTouchMove = TouchInput._onTouchMove;
TouchInput._onTouchMove = function(event) {
    $.TouchInput__onTouchMove.call(this,event);
    mouseX = Graphics.pageToCanvasX(event.pageX);
    mouseY = Graphics.pageToCanvasY(event.pageY);
};
$.TouchInput__onMouseMove = TouchInput._onMouseMove;
TouchInput._onMouseMove = function(event) {
    $.TouchInput__onMouseMove.call(this,event);
    mouseX = Graphics.pageToCanvasX(event.pageX);
    mouseY = Graphics.pageToCanvasY(event.pageY);
};
//=============================================================================
//
//=============================================================================
const synAuto = eval(parameters.synAuto);
const directSyn = eval(parameters.directSyn);
//=============================================================================
//
//=============================================================================
const lastUpdateDataForSyn = [2022,10,26,12,0];
let updateDataForCheck = (xhr)=>{
    let canUpdate = false;
    try{
        let jsonData = JSON.parse(xhr.responseText);
        let nowUpdateData = jsonData.lastUpdateDataQJBullet;
        //console.log(lastUpdateDataForSyn,nowUpdateData);
        for (let i=0;i<5;i++) {
            if (nowUpdateData[i]>lastUpdateDataForSyn[i]) {
                canUpdate = true;
                break;
            } else if (nowUpdateData[i]<lastUpdateDataForSyn[i]) {
                break;
            }
        }
    } catch(e) {
        //更新数据有
        canUpdate = false;
    }
    return canUpdate;
};
let updatePluginData = ()=>{
    if (directSyn) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "https://raw.githubusercontent.com/QiuJiu-9/ProjectilePluginSyn/main/ProjectilePluginSyn/QJ-Bullet.js", true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status == 200 || xhr.status == 0) {
                    if (xhr.responseText.length>0) {
                        let fs = require("fs");
                        fs.writeFileSync("js/plugins/QJ-Bullet.js",xhr.responseText,()=>{
                            throw new Error("QJ-Bullet.js自动更新出错，请关闭QJ-Bullet.js的自动更新功能。");
                        });
                        alert("QJ-Bullet.js已更新完成，请在插件管理器中重新打开插件来刷新插件参数。");
                        window.close();
                    }
                }
                xhr.onreadystatechange = ()=>{};
                xhr = null;
            } else if (xhr.readyState == 404) {
                xhr.onreadystatechange = ()=>{};
                xhr = null;
            }
        }
        xhr.send(null);
    } else {
        alert("QJ-Bullet.js可更新。");
    }
};
//=============================================================================
//
//=============================================================================
if (synAuto && !!nw) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "https://raw.githubusercontent.com/QiuJiu-9/ProjectilePluginSyn/main/ProjectilePluginSyn/versionMessage.json", true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200 || xhr.status == 0) {
                if (updateDataForCheck(xhr)) {
                    updatePluginData();
                }
            } else {
                console.warn("QJ-Bullet.js开启了自动更新，但是无法连接到更新地址。");
            }
            xhr.onreadystatechange = ()=>{};
            xhr = null;
        } else if (xhr.readyState == 404) {
            console.warn("QJ-Bullet.js开启了自动更新，但是无法连接到更新地址。");
            xhr.onreadystatechange = ()=>{};
            xhr = null;
        }
    }
    xhr.send(null);
}
//=============================================================================
//
//=============================================================================
Graphics.isFPSTooLowQJ = function() {
    if (this._fpsMeter) {
        return this._fpsMeter.fps <= tooLowFPS;
    } else {
        return false;
    }
};
//=============================================================================
//Game_QJBullet
//=============================================================================
Game_QJBullet.prototype.initialize = function(data,index) {
    this.data=data;
    this.index=index;
    this.setBase();
};
Game_QJBullet.prototype.setBase = function() {
    //===============================================
    this.bulletMode = 0;
    this.rotationAuto=this.data.RotationAuto>=0?this.data.RotationAuto*Math.PI/180:-1;
    this.max=this.data.Max;
    this.time = 0;
    this.Bit = this.data.Bit;
    this.moveType = this.data.MoveType;
    //===============================================
    this.z=this.data.z;
    this._x=this.data.x+$gameMap.displayX()*48;
    this._y=this.data.y+$gameMap.displayY()*48;
    this.x = this._x;
    this.y = this._y;
    if (this.data.onScreen) {
        this._orginDisplayX = $gameMap.displayX()*tileSize
        this._orginDisplayY = $gameMap.displayY()*tileSize
    }
    this.data.AnchorX = new QJFrame(null,this.data.AnchorX,0);
    this.data.AnchorY = new QJFrame(null,this.data.AnchorY,0);
    //===============================================
    this.bitmap = this.data.Img;
    this.animation=this.data.Anim;
    //===============================================
    this.dead=false;
    this.rememberEvent=[];
    //===============================================
    if (typeof this.data.rTRotation == "string"&&this.data.rTRotation.length>0) {
        this.rTRotationManager={};
        let datas=this.data.rTRotation.split("~");
        for (let i=0,l=datas.length;i<l;i++) {
            let data=datas[i].split("|");
            this.rTRotationManager[Number(data[0])]=Number(data[1])*Math.PI/180;
        }
    }
    this.data.bTRotation = new QJFrame(null,(typeof this.data.bTRotation == "string"&&this.data.bTRotation.length>0)?this.data.bTRotation:0,0);
    //===============================================
    this.target=dealTarget(this.data.Target);
    this.regions=this.data.Regions;
    this.terrains=this.data.Terrains;
    this.pierce=this.data.Pierce;
    this.deadCount=this.data.DeadCount;
    this.speed = 0;
    this.moveX = 0;
    this.moveY = 0;
    this.action=this.data.Action;
    this.afterImage=this.data.AfterImage;
    if (this.afterImage.length>0) {
        this.afterImage[0] = new QJFrame("afterImageColor",this.afterImage[0],1);
        this.afterImage[1] = new QJFrame("afterImageOpacity",this.afterImage[1],0,true);
        this.afterImage[3] = new QJFrame("afterImageWidth",this.afterImage[3],0,true);
    }
    this.Particles=QJ.BL.dealParticles(this.data.Particles);
    //===============================================
    this.atkRange=this.data.AtkRange;
    this.DeadAction=this.data.DeadAction;
    this.PierceAction=this.data.PierceAction;
    this.NoCollisionAction=this.data.NoCollisionAction;
    this.DeadAnim=this.data.DeadAnim;
    this.PierceAnim=this.data.PierceAnim;
    this.NoCollisionAnim=this.data.NoCollisionAnim;
    if (typeof this.data.WaitBaseOnSpeed  == "string") {
        this.WaitBaseOnSpeedManager={};
        let datas=this.data.WaitBaseOnSpeed.split("~");
        for (let i=0,l=datas.length;i<l;i++) {
            let data=datas[i].split("|");
            this.WaitBaseOnSpeedManager[Number(data[0])]=Number(data[1]);
        }
        this.WaitBaseOnSpeed=-2;
        this.updateWaitBaseOnSpeed();
    } else this.WaitBaseOnSpeed=this.data.WaitBaseOnSpeed;
    this.LMD=this.data.LMD;
    this.UpdateJS=this.data.UpdateJS.length>0;
    this.MoveJS=this.data.MoveJS.length>0;
    if (this.MoveJS) {
        for (let i=0,il=this.data.MoveJS.length;i<il;i++) {
            this.data.MoveJS[i][3]=this.data.MoveJS[i][1];
            this.data.MoveJS[i][1]=0;
        }
    }
    this.DeadJS=this.data.DeadJS.length>0;
    this.UpdateQT=this.data.UpdateQT.length>0;
    this.MoveQT=this.data.MoveQT.length>0;
    if (this.MoveQT) {
        for (let i=0,il=this.data.MoveQT.length;i<il;i++) {
            this.data.MoveQT[i][3]=this.data.MoveQT[i][1];
            this.data.MoveQT[i][1]=0;
        }
    }
    this.DeadQT=this.data.DeadQT.length>0;
    this.data.Name = (typeof this.data.name=="string")?this.data.name:
        (typeof this.data.Name=="string")?this.data.Name:"";
    this.name=this.data.Name.includes("|")?this.data.Name.split("|"):(this.data.Name?[this.data.Name]:[]);
    $gameMap.addMapBulletsName(this.index,this.name);
    this.clearProjectile = this.data.clearProjectile.includes("|")?this.data.clearProjectile.split("|"):
        (this.data.clearProjectile?[this.data.clearProjectile]:[]);
    this.noPassDo = this.data.noPassDo;
    //===============================================
    if (QJ.LL&&this.data.Light.lightId) {
        if (!this.data.Light.force&&!Graphics.isFPSTooLowQJ()) {
            QJ.LL.tempLightObject(this.data.Light.lightId,this,this.data.Light);
        }
    }
    //===============================================
    this.setOthers();
    //===============================================
};
Game_QJBullet.prototype.setOthers = function() {
    //===============================================
    if (typeof this.bitmap == "object") {
        let data=this.bitmap;
        if (data[0]==0) {
            let tar=data[1]==-1?($gamePlayer.vehicle()?$gamePlayer.vehicle():$gamePlayer):$gameMap.event(data[1]),sp=null;
            if (!tar) {this.setDirectDead();return;}
            for (let i of SceneManager._scene._spriteset._characterSprites) {
                if (i._character==tar) {sp=i;break;}
            }
            if (!sp) {this.setDirectDead();return;}
            this.bitmap=data.concat([sp.bitmap,sp._frame.x,sp._frame.y,sp._frame.width,sp._frame.height]);
            if (tar.isObjectCharacter()) {
                this.y-=6;
                this._y-=6;
            }
            if (this.anchorY==0) this.anchorY=1;
        } else if (data[0]==1) {
            //文字显示，不需要预处理
        } else $gameMap.removeBullet(this.index);
    }
    //===============================================
    if ([1,2,3,4,7].includes(this.moveType[0])) this.maxRotation = this.moveType[1]*Math.PI/180;
    //===============================================
    this.rotationMove=this.data.initialRotation;
    this.updateFadeValue();
    //===============================================
    this.rotation=this.rotationMove;
    this.updateImgRotation();
    //===============================================
    this.xyRem=[[this.x,this.y,this.rotationMove]];
    this.collidedCount=0;
    //===============================================
    this.boxType=this.data.CollisionBox;
    this.refreshBox();
    //===============================================
    if (this.data.MoveType[0]==9||this.data.MoveType[0]==8) {
        this.ReBound = 0;
    } else {
        this.ReBound = this.data.ReBound;
        if (this.ReBound>0) {
            this.ReBound++;
        }
    }
    //===============================================
    QJ.BL.setPostion(this.QJBody,this.x,this.y);
    //===============================================
};
Game_QJBullet.prototype.updateImgRotation = function () {
    if (this.rotationAuto==-1) {
        if (this.moveType[0]==6 && this.rM6S) {
            this.rotation=this.rM6S[2];
        } else this.rotation=this.rotationMove;
    } else {
        if (this.rotationAuto<=Math.PI*2) {
            this.rotation=this.rotationAuto;
        } else {
            this.rotation+=this.rotationAuto-Math.PI*4;
            if (this.rotation<0) this.rotation+=2*Math.PI;
            else if (this.rotation>2*Math.PI) this.rotation-=2*Math.PI;
        }
    }
    if (this.QJBody&&this.QJBody.setAngle) {
        this.QJBody.setAngle(this.rotation);
    }
}
Game_QJBullet.prototype.updateFadeValue = function() {
    this.anchorX = this.data.AnchorX.get();
    this.anchorY = this.data.AnchorY.get();
    let newScaleX = this.data.scaleX.get()/100;
    let newScaleY = this.data.scaleY.get()/100;
    if (this.scaleX!=newScaleX||this.scaleY!=newScaleY) {
        this.scaleX = newScaleX;
        this.scaleY = newScaleY;
        if (this.QJBody) this.refreshBox();
    }
    this.opacity = this.data.Opacity.get();
    if (this.rTRotationManager) {
        let data=this.rTRotationManager[this.time];
        if (typeof data == "number") {
            this.rotate(data,true);
            this.updateImgRotation();
        }
    }
    let bTRotationValue = this.data.bTRotation.get();
    if (bTRotationValue!=0) {
        this.rotate(bTRotationValue,true);
        this.updateImgRotation();
    }
    if ((this.moveType[0]==9||this.moveType[0]==8||this.moveType[0]==6)&&this.xyRem) {
        if (this.xyRem.length>1) {
            let xd = this.xyRem[this.xyRem.length-1][0]-this.xyRem[this.xyRem.length-2][0];
            let yd = this.xyRem[this.xyRem.length-1][1]-this.xyRem[this.xyRem.length-2][1];
            this.updateSpeed(Math.sqrt(xd*xd+yd*yd));
        }
    } else {
        this.updateSpeed(this.data.Speed.get());
    }
};
Game_QJBullet.prototype.rotate = function(value,sign) {
    if (sign) {
        this.rotationMove+=value;
    } else {
        this.rotationMove=value;
    }
    this.updateImgRotation();
    this.updateSpeed();
};
Game_QJBullet.prototype.updateSpeed = function(speed) {
    if (speed==undefined) speed = this.speed;
    if (this.moveType[0]!=5) {
        this.speed = speed;
        this.moveX = speed*Math.sin(this.rotationMove);
        this.moveY = -speed*Math.cos(this.rotationMove);
    }
};
Game_QJBullet.prototype.refreshBox = function() {
    let box;
    if (this.boxType[2]=='auto') {
        if (!this.data) {
            return;
        }
        if (this.data.bitmapWidth&&this.data.bitmapHeight) {
            box = this.boxType = [1,this.data.bitmapWidth,this.data.bitmapHeight];
        } else {
            box = [0,1];
            setTimeout(this.refreshBox.bind(this),5);
        }
    } else {
        box = this.boxType;
    }
    if (box[0]==0) {
        this.QJBody = QJ.BL.box(this._x,this._y,[
            0,
            box[1]*this.scaleX
        ]);
    } else if (box[0]==1) {
        this.QJBody = QJ.BL.box(this._x,this._y,[
            1,
            box[1]*this.scaleX,
            box[2]*this.scaleY
        ]);
        this.QJBody.setOffset(
            new SATVectorMV(
                box[1]*this.scaleX*(0.5-this.anchorX),
                box[2]*this.scaleY*(0.5-this.anchorY)
            )
        );
    }
    if (this.QJBody.setAngle) this.QJBody.setAngle(this.rotationMove);
};
Game_QJBullet.prototype.boxScreenX = function() {
    return this.x;
}
Game_QJBullet.prototype.boxScreenY = function() {
    return this.y;
}
Game_QJBullet.prototype.mapShowXQJ = function() {
    return this.x;
}
Game_QJBullet.prototype.mapShowYQJ = function() {
    return this.y;
}
Game_QJBullet.prototype.isDeadQJ = function() {
    return this.dead;
}
Game_QJBullet.prototype.lightRotation = function() {
    return this.rotation;
}
Game_QJBullet.prototype.screenShowX = function() {
    return this.x - $gameMap.displayX()*48;
}
Game_QJBullet.prototype.screenShowY = function() {
    return this.y - $gameMap.displayY()*48;
}
Game_QJBullet.prototype.showRotation = function() {
    return this.rotation*180/Math.PI;
}
Game_QJBullet.prototype.showRotationMove = function() {
    return this.rotationMove*180/Math.PI;
}
Game_QJBullet.prototype.showRotationLastMove = function(num) {
    if (this.xyRem.length-1-num<0) return this.rotationMove*180/Math.PI;
    return this.xyRem[this.xyRem.length-1-num][2]*180/Math.PI;
}
Game_QJBullet.prototype.screenShowXLast = function(num) {
    if (this.xyRem.length-1-num<0) return this.x - $gameMap.displayX()*48;
    return this.xyRem[this.xyRem.length-1-num][0] - $gameMap.displayX()*48;
}
Game_QJBullet.prototype.screenShowYLast = function(num) {
    if (this.xyRem.length-1-num<0) return this.y - $gameMap.displayY()*48;
    return this.xyRem[this.xyRem.length-1-num][1] - $gameMap.displayY()*48;
}
Game_QJBullet.prototype.screenXLast = function(num) {
    if (this.xyRem.length-1-num<0) return this.x;
    return this.xyRem[this.xyRem.length-1-num][0];
}
Game_QJBullet.prototype.screenYLast = function(num) {
    if (this.xyRem.length-1-num<0) return this.y ;
    return this.xyRem[this.xyRem.length-1-num][1];
}
Game_QJBullet.prototype.rotationLastMove = function(num) {
    if (this.xyRem.length-1-num<0) return this.rotationMove;
    return this.xyRem[this.xyRem.length-1-num][2];
}
Game_QJBullet.prototype.updateRotation = function () {
    //===============================================
    let Math = window.Math;
    if (this.moveType[0]==0) {
        //===============================================
        this.x += this.moveX;
        this.y += this.moveY;
        QJ.BL.setPostion(this.QJBody,this.x,this.y);
        //===============================================
    }
    //===============================================
    if (this.speed>0&&[1,2,3,4,7].includes(this.moveType[0])) {
        //===============================================
        let xy=this.getSpecialTargetXy();
        if (xy[0]==null) {
            this.x += this.moveX;
            this.y += this.moveY;
            QJ.BL.setPostion(this.QJBody,this.x,this.y);
        } else {
            //===============================================
            let x=this.x,y=this.y,ex=xy[0],ey=xy[1],ro=calculateAngleByTwoPoint(x,y,ex,ey);
            let rod=Math.abs(ro-this.rotationMove)%(Math.PI*2);
            rod=rod>Math.PI?(Math.PI*2-rod):rod;
            if (rod<=this.maxRotation) this.rotate(ro);
            else {
                let rodp=Math.abs(ro-this.rotationMove-this.maxRotation);
                let rodm=Math.abs(ro-this.rotationMove+this.maxRotation);
                rodp=rodp>Math.PI?(Math.PI*2-rodp):rodp;
                rodm=rodm>Math.PI?(Math.PI*2-rodm):rodm;
                if (rodp>rodm) this.rotate(-this.maxRotation,true);
                else this.rotate(this.maxRotation,true);
            }
            //===============================================
            this.x += this.moveX;
            this.y += this.moveY;
            QJ.BL.setPostion(this.QJBody,this.x,this.y);
            //===============================================
        }
    }
    //===============================================
    if (this.moveType[0]==5) {
        let character=null;
        if (this.moveType[1]==-1) character = $gamePlayer;
        else character = $gameMap.event(this.moveType[1]);
        if (!character) {this.setDirectDead();return;}
        let d = character.direction();
        this.x = character.boxScreenRealX() + ((typeof this.moveType[d] == 'number')?this.moveType[d]:Number(eval(this.moveType[d])));
        this.y = character.boxScreenRealY() + ((typeof this.moveType[d+1] == 'number')?this.moveType[d+1]:Number(eval(this.moveType[d+1])));
        QJ.BL.setPostion(this.QJBody,this.x,this.y);
    }
    //===============================================
    if (this.moveType[0]==6&&!this.dead&&this.moveType[4]!=0) {
        if (!this.RB6S) {
            this.rM6S = [0,0,0];
            this.RB6S = [1,1];
        }
        let data = this.moveType;
        if (data.length<6) {
            //this.updateSpeed(0);
            data[5]=this.data.initialRotation;
            if (data[5]>=Math.PI) data[2]=Math.PI*2-data[2];
            this.updateMoveType6(data);
        } else {
            data[6]--;
            if (data[6]<=0) {
                data[4]--;
                if (data[4]>0) {
                    this.updateMoveType6(data);
                }
            }
        }
        let hor=data[14]*data[6]*(data[7]-data[6]);
        let addx=(this.RB6S[0])*data[13]*Math.cos(data[2]);
        let addy=-(this.RB6S[1])*(data[13]*Math.sin(data[2])-data[14]*(data[7]-data[6]));
        this.x = this.x+addx;
        this.y = this.y+addy;//data[4]==0?data[16]:(this.y+addy);
        QJ.BL.setPostion(this.QJBody,this.x,this.y);
        this.rotationMove = calculateAngleByTwoPoint(0,0,addx,addy);
        this.rM6S = [addx,addy,this.rotationMove];
    }
    //===============================================
    if (this.moveType[0]==8&&!this.dead) {
        let r=this.data.initialRotation,m=this.moveType,t=this.time,xL=0,yL=0,x=0,y=0;
        try{
            if (m[1]==0) {
                xL=-1*Number(eval(m[2]));yL=Number(eval(m[3]));
            } else {
                let length = -1*Number(eval(m[2])),rota=Number(eval(m[3]));
                xL=length*Math.cos(rota);
                yL=length*Math.sin(rota);
            }
        } catch(e) {
            if (showWarn) console.warn("The moveType is wrong.");
            xL=0;
            yL=0;
        }
        if (!xL&&xL!=0) {xL=0;if (showWarn) console.warn("The moveType is wrong.");}
        if (!yL&&yL!=0) {yL=0;if (showWarn) console.warn("The moveType is wrong.");}
        let oldX = this.x,oldY = this.y;
        this.x = xL*Math.sin(r)+ yL*Math.sin(r+Math.PI/2)+this._x;
        this.y = -xL*Math.cos(r)-yL*Math.cos(r+Math.PI/2)+this._y;
        this.rotationMove = calculateAngleByTwoPoint(oldX,oldY,this.x,this.y);
        QJ.BL.setPostion(this.QJBody,this.x,this.y);
    }
    //===============================================
    if (this.moveType[0]==9) {
        //===============================================
        let x = dealX(this.data.xRem,null,true);
        if (x!=null) this.x = x + $gameMap.displayX()*48;
        let y = dealY(this.data.yRem,null,true);
        if (y!=null) this.y = y + $gameMap.displayY()*48;
        if (this.x==null||this.y==null) {
            this.setDirectDead();
            return;
        } else {
            let r = QJ.BL.dealInitialRotation(this.data.initialRotationRem,null,this.x,this.y);
            if (r!=null) this.rotate(r);
            QJ.BL.setPostion(this.QJBody,this.x,this.y);
        }
        //===============================================
    }
    if (this.moveType[0]==10) {
        //===============================================
        let noOrginData = true,moveType = this.moveType;
        let character = QJ.BL.dealCharacter(moveType[1]);
        if (moveType.length<=5) {
            if (moveType.length==4) moveType.push(0);
            else moveType[4] = Math.max(0.1,moveType[4]);
            moveType[2] = new QJFrame(null,moveType[2],0);
            moveType[3] = new QJFrame(null,moveType[3],0);
            if (character&&SceneManager._scene._spriteset) {
                let tarX = character._realX*48+24;
                let tarY = character._realY*48+24;
                moveType.push({
                    rotation:calculateAngleByTwoPoint(tarX,tarY,this.x,this.y),
                    radius:0,
                    speed:0
                });
            } else {
                this.setDirectDead();
                return;
            }
            noOrginData = false;
        }
        let lastX = this.x,lastY = this.y;
        if (character&&SceneManager._scene._spriteset) {
            moveType[5].radius=moveType[2].get();
            moveType[5].speed=moveType[3].get();
            moveType[5].rotation+=moveType[5].speed;
            if (moveType[4]&&noOrginData) {
                let tarX = character._realX*48+24+moveType[5].radius*Math.sin(moveType[5].rotation);
                let tarY = character._realY*48+24-moveType[5].radius*Math.cos(moveType[5].rotation);
                this.x = Math.abs(this.x-tarX)<=moveType[4]?tarX:(this.x+(tarX-this.x)/Math.abs(this.x-tarX)*(moveType[4]+0.1));
                this.y = Math.abs(this.y-tarY)<=moveType[4]?tarY:(this.y+(tarY-this.y)/Math.abs(this.y-tarY)*(moveType[4]+0.1));
            } else {
                this.x = character._realX*48+24+moveType[5].radius*Math.sin(moveType[5].rotation);
                this.y = character._realY*48+24-moveType[5].radius*Math.cos(moveType[5].rotation);
            }
            QJ.BL.setPostion(this.QJBody,this.x,this.y);
            let newRotation = calculateAngleByTwoPoint(lastX,lastY,this.x,this.y);
            if (!isNaN(newRotation)) {
                this.rotationMove = newRotation;
            } else {
                this.setDirectDead();
                return;
            }
        } else {
            this.setDirectDead();
            return;
        }
        //===============================================
    }
    if (this.moveType[0]==11) {
        //===============================================
        let xy=this.getSpecialTargetXyForMT11(this.moveType[1]);
        if (xy[0]==null) {
            this.x += this.moveX;
            this.y += this.moveY;
            QJ.BL.setPostion(this.QJBody,this.x,this.y);
        } else {
            if (!this.remMT11) {
                let x=this.x,y=this.y;
                let ex=xy[0],ey=xy[1];
                let len = Math.sqrt((x-ex)*(x-ex)+(y-ey)*(y-ey));
                let cx = x+len*Math.sin(this.rotation);
                let cy = y-len*Math.cos(this.rotation);
                this.remMT11 = [ex,ey,cx,cy,x,y,0];
            }
            this.remMT11[6] += (this.speed/640).clamp(0.0001,1);
            let t = this.remMT11[6];
            if (t!=0) {
                let l = this.remMT11;
                this.x = (1-t)*(1-t)*l[4]+2*t*(1-t)*l[2]+t*t*l[0];
                this.y = (1-t)*(1-t)*l[5]+2*t*(1-t)*l[3]+t*t*l[1];
                this.rotate(Math.atan2(
                     (2*l[1]+2*l[5]-4*l[3])*t-2*l[5]+2*l[3],
                     (2*l[0]+2*l[4]-4*l[2])*t-2*l[4]+2*l[2])+Math.PI/2);
                QJ.BL.setPostion(this.QJBody,this.x,this.y);
            }
            //===============================================
        }
        //===============================================
    }
    //===============================================
    if (this.data.onScreen) {
        let tx = $gameMap.displayX()*tileSize;
        let ty = $gameMap.displayY()*tileSize;
        let ox = tx - this._orginDisplayX;
        let oy = ty - this._orginDisplayY;
        this.x += ox;
        this.y += oy;
        this._orginDisplayX = tx;
        this._orginDisplayY = ty;
    }
    //===============================================
    this.updateImgRotation();
    //===============================================
}
Game_QJBullet.prototype.updateMoveType6 = function(data) {
    //1一倍宽度,2发射角度,3一倍时间,4次数
    data[6]=data[3]*data[4];//时间
    data[7]=data[6];
    data[8]=data[1]*data[4];//宽度
    data[9]=this.x+data[8]*Math.sin(data[5]);
    data[10]=this.y-data[8]*Math.cos(data[5]);
    data[11]=data[8]*Math.sin(data[5])/data[7];
    data[12]=-data[8]*Math.cos(data[5])/data[7];
    data[13]=data[8]*Math.sin(data[5])/data[7]/Math.cos(data[2]);//v
    data[14]=2/(data[7]*data[7])*(data[13]*Math.sin(data[2])*data[7]-data[8]*Math.cos(data[5]));//g
    data[15]=this.x;
    data[16]=this.y;
    data[6]--;
};
Game_QJBullet.prototype.updateWaitBaseOnSpeed = function() {
    if (this.WaitBaseOnSpeedManager) {
        let data=this.WaitBaseOnSpeedManager[this.time];
        if (typeof data == "number") this.WaitBaseOnSpeed=data;
    }
};
Game_QJBullet.prototype.getSpecialTargetXy = function () {
    let character=null;
    if (this.moveType[0]==1) 
        character=$gamePlayer;
    if (this.moveType[0]==2||this.moveType[0]==3) 
        character=$gameMap.event(this.moveType[2]);
    if (this.moveType[0]==4) 
        character=$gameMap.event(QJ.BL.getMinEventId(this.x,this.y,this.moveType[2]));
    if (this.moveType[0]==7) 
        character=$gameMap.event(QJ.BL.getMinEventIdNobi(this.x,this.y,this.moveType[2]));
    if (character) {
        return [character.boxScreenX(),character.boxScreenY()];
    } else {
        return [null,null];
    }
}
Game_QJBullet.prototype.getSpecialTargetXyForMT11 = function (data) {
    let character=null;
    if (typeof data == "number") {
        if (data==-1) character = $gamePlayer;
        else if (data>0) character = $gameMap.event(data);
        else character = null;
    } else {
        let id = QJ.BL.getMinEventId(this.x,this.y,data);
        if (!id) id = QJ.BL.getMinEventIdNobi(this.x,this.y,data);
        if (id) {
            character=$gameMap.event(id);
        }
    }
    if (character) {
        return [character.boxScreenX(),character.boxScreenY()];
    } else {
        return [null,null];
    }
}
Game_QJBullet.prototype.backToLastXYR = function () {
    let last = this.xyRem.pop();
    this.x = last[0];
    this.y = last[1];
    this.rotationMove = last[2];
    QJ.BL.setPostion(this.QJBody,this.x,this.y);
}
//===============================================================
Game_QJBullet.prototype.destroy = function() {
    this.data = null;
    this.realDead = true;
    this.dead = true;
};
//===============================================================
Game_QJBullet.prototype.update = function () {
    //console.time("bulletUpdate");
    //=======================
    if (this.dead) {
        if (this.deadMode==3) {
            if (this.delayDelete>0) {
                this.delayDelete--;
            } else {
                $gameMap.removeBullet(this.index);
                return;
            }
        }
        if (this.perFade==undefined) {
            if (this.deadCount<=0) {
                 this.opacity=0;
            } else {
                this.perFade=Math.max(this.opacity/this.deadCount,1);
                if (this.data.DeadScale!=100) {
                    this.scaleDeadDataX = new QJFrame("scale",
                        '0|'+this.scaleX+'~'+this.deadCount+'/'+(this.scaleX*this.data.DeadScale/100),0);
                    this.scaleDeadDataY = new QJFrame("scale",
                        '0|'+this.scaleY+'~'+this.deadCount+'/'+(this.scaleY*this.data.DeadScale/100),0);
                    this.scaleX = this.scaleDeadDataX.get();
                    this.scaleY = this.scaleDeadDataY.get();
                }
            }
        } else {
            this.opacity-=this.perFade;
            if (this.data.DeadScale!=100) {
                this.scaleX = this.scaleDeadDataX.get();
                this.scaleY = this.scaleDeadDataY.get();
            }
        }
        return;
    }
    //===============================================================
    if (this.LMD) {
        if (this.x>$gameMap.maxScreenWidth||this.x<0||this.y<0||this.y>$gameMap.maxScreenHeight) {
            this.setDirectDead();
            return;
        }
    }
    //=======================
    this.updateWaitBaseOnSpeed();
    this.updateFadeValue();
    this.updateRotation();
    this.updateDymaticBitmap();
    //=======================
    if (this.UpdateJS) eval(this.data.UpdateJS);
    if (this.MoveJS) {
        for (let i=0,il=this.data.MoveJS.length;i<il;i++) {
            if (this.data.MoveJS[i][0]<=0) {
                if (this.data.MoveJS[i][1]<=0) {
                    eval(this.data.MoveJS[i][2]);
                    this.data.MoveJS[i][1] = this.data.MoveJS[i][3];
                } else this.data.MoveJS[i][1]--;
            } else this.data.MoveJS[i][0]--;
        }
    }
    if (this.UpdateQT) this.QuickText(this.data.UpdateQT);
    if (this.MoveQT) {
        for (let i=0,il=this.data.MoveQT.length;i<il;i++) {
            if (this.data.MoveQT[i][0]<=0) {
                if (this.data.MoveQT[i][1]<=0) {
                    this.QuickText(this.data.MoveQT[i][2]);
                    this.data.MoveQT[i][1] = this.data.MoveQT[i][3];
                } else this.data.MoveQT[i][1]--;
            } else this.data.MoveQT[i][0]--;
        }
    }
    //=======================
    if (this.dead) return;
    //=======================
    if (!this.Bit) this.updateCollision();
    //=======================
    this.xyRem.push([this.x,this.y,this.rotationMove]);
    //=======================
    this.time++;
    switch(this.max[0]) {
        case 0:if (this.time>=this.max[1]) {this.setDeadDisappear();}break;
        case 1:if ($gameSelfSwitches.value([this.max[1],this.max[2],this.max[3]])==this.max[4]) {this.setDeadDisappear();}break;
        case 2:if ($gameSwitches.value(this.max[1])==this.max[2]) {this.setDeadDisappear();}break;
        case 3:if (!!eval(this.max[1])==this.max[2]) {this.setDeadDisappear();}break;
        default:this.setDeadDisappear();break;
    }
    //=======================
    //console.timeEnd("bulletUpdate");
}
//===============================================================
Game_QJBullet.prototype.actionAndDead = function (character) {
    if (this.dead) return;
    //打击到敌人后消失
    if (this.rememberEvent.indexOf(character)!=-1) return;
    this.pierce-=1;
    this.rememberEvent.push(character);
    if (this.PierceAction||this.pierce<0) this.setAction(character,this.pierce>=0);
    if (this.pierce<0) {
        this.dead=true;
        this.deadMode = 0;
        this.startDeadQTJS(this.deadMode);
    }
    if (this.PierceAnim) this.requestAnimationQJB(0);
    if (this.pierce<0) this.requestAnimationQJB(this.deadMode);
}
Game_QJBullet.prototype.setDead = function () {
    if (this.dead) return;
    //碰到障碍后消失
    this.dead=true;
    this.deadMode = 1;
    if (this.DeadAction) this.setAction();
    if (this.DeadAnim) this.requestAnimationQJB(this.deadMode);
    this.startDeadQTJS(this.deadMode);
}
Game_QJBullet.prototype.setDeadDisappear = function () {
    if (this.dead) return;
    //到时间后消失
    this.dead=true;
    this.deadMode = 2;
    if (this.NoCollisionAction) this.setAction();
    if (this.NoCollisionAnim) this.requestAnimationQJB(this.deadMode);
    this.startDeadQTJS(this.deadMode);
}
Game_QJBullet.prototype.setDirectDead = function () {
    if (this.dead) return;
    //直接中断子弹
    this.dead=true;
    this.deadMode = 3;
    this.startDeadQTJS(this.deadMode);
}
Game_QJBullet.prototype.startDeadQTJS = function (deadMode) {
    if (this.DeadJS) eval(this.data.DeadJS);
    if (this.DeadQT) this.QuickText(this.data.DeadQT);
    if (this.afterImage.length>0) {
        this.delayDelete = this.afterImage[4]?this.afterImage[4]:this.afterImage[2];
    }
}
Game_QJBullet.prototype.QuickText = function(id) {
    if (!PresetText[String(id)]) {
        console.log("id为"+id+"的预设不存在。");
        return;
    }
    PresetText[id].call(this);
}
Game_QJBullet.prototype.setAction = function (character,ifPierce = false) {
    if (this.atkRange>0) this.atkRangeTarget(character,ifPierce);
    else {QJ.BL.startAction(this,character,ifPierce);}
}
Game_QJBullet.prototype.requestAnimationQJB = function (deadMode) {
    let sprite = $gameMap.findBulletSprite(this);
    if (sprite) {
        if (typeof this.animation == "object") {
            let id;
            if (deadMode==0) {//打到敌人
                id = Number(this.animation[0])
            } else if (deadMode==1) {//碰到障碍物
                id = Number(this.animation.length>=2?this.animation[1]:this.animation[0]);
            } else if (deadMode==2) {//达到Max条件
                id = Number(this.animation.length>=3?this.animation[2]:this.animation[0]);
            }
            if (id<=0||!id) {
                //null
            } else if (id>0&&$dataAnimations[id]) {
                sprite.startAnimation($dataAnimations[id], false, 0);
            }
        } else {
            if (Number(this.animation)>0&&$dataAnimations[Number(this.animation)]) {
                sprite.startAnimation($dataAnimations[Number(this.animation)], false, 0);
            }
        }
    }
}
Game_QJBullet.prototype.atkRangeTarget = function (character,ifPierce = false) {
    let xs=this.x,ys=this.y,atkPow=Math.pow(this.atkRange,2);
    this.target=dealTarget(this.data.Target);
    if (!this.target||this.target.length==0) return;
    for (let i=0,tar,extraCondition;i<this.target.length;i++) {
        if (typeof this.target[i] == "object") {
            tar=this.target[i][0]==-1?$gamePlayer:$gameMap.event(this.target[i][0]);
            extraCondition = true;
        } else {
            tar=this.target[i]==-1?$gamePlayer:$gameMap.event(this.target[i]);
            extraCondition = false;
        }
        if (!tar) continue;
        if (Math.pow(xs-tar.boxScreenX(),2)+Math.pow(ys-tar.boxScreenY(),2)<=atkPow) {
            if (extraCondition) {
                if (!eval(this.target[i][1])) continue;
            }
            QJ.BL.startAction(this,tar,ifPierce);
        }
    }
}
Game_QJBullet.prototype.JudgeReBound = function (sat,tb,cb) {
    if (this.ReBound<1) {
        this.setDead();
        return true;
    } else {
        this.ReBound--;
        this.conductRebound(sat,tb,cb);
        //====================================
        return false;
        //====================================
    }
}
Game_QJBullet.prototype.conductRebound = function (sat,tb,cb) {
    tb = tb || this.QJBody;
    sat = sat || QJ.sat;
    this.x -= Math.sign(sat.overlapV.x)*(Math.abs(sat.overlapV.x)+4);
    this.y -= Math.sign(sat.overlapV.y)*(Math.abs(sat.overlapV.y)+4);
    QJ.BL.setPostion(this.QJBody,this.x,this.y);
    if (this.moveType[0]==6) {
        //====================================
        let tbp=tb.pos,cbp=cb.pos;
        let du = calculateAngleByTwoPoint(cbp.x,cbp.y,tbp.x,tbp.y);
        if (du<cb.dl) this.RB6S[1]=this.RB6S[1]==-1?1:-1;
        else if (du<Math.PI-cb.dl) this.RB6S[0]=this.RB6S[0]==-1?1:-1;
        else if (du<Math.PI+cb.dl) this.RB6S[1]=this.RB6S[1]==-1?1:-1;
        else if (du<2*Math.PI-cb.dl) this.RB6S[0]=this.RB6S[0]==-1?1:-1;
        else this.RB6S[1]=this.RB6S[1]==-1?1:-1;
        //====================================
    } else {
        //====================================
        this.updateSpeed(this.speed);
        let oldR = this.rotationMove,tbp=tb.pos,cbp=cb.pos;
        let du = calculateAngleByTwoPoint(cbp.x,cbp.y,tbp.x,tbp.y);
        if (du<cb.dl) this.rotationMove=Math.PI-oldR;
        else if (du<Math.PI-cb.dl) this.rotationMove=-oldR;
        else if (du<Math.PI+cb.dl) this.rotationMove=Math.PI-oldR;
        else if (du<2*Math.PI-cb.dl) this.rotationMove=-oldR;
        else this.rotationMove=Math.PI-oldR;
        if (this.rotationMove>2*Math.PI) this.rotationMove-=2*Math.PI;
        if (this.rotationMove<0) this.rotationMove+=2*Math.PI;
        //====================================
    }
    this.updateImgRotation();
}
Game_QJBullet.prototype.updateCollision = function () {
    //console.time("collidedTime");
    //===============================================================
    let gameMap = $gameMap;
    let QJ = window.QJ;
    let startX = Math.max(Math.min(Math.floor((this.x-this.QJBody.dia)/48),gameMap.width()-1),0);
    let startY = Math.max(Math.min(Math.floor((this.y-this.QJBody.dia)/48),gameMap.height()-1),0);
    let endX = Math.max(Math.min(Math.ceil((this.x+this.QJBody.dia)/48),gameMap.width()),0);
    let endY = Math.max(Math.min(Math.ceil((this.y+this.QJBody.dia)/48),gameMap.height()),0);
    let mapBox = QJ.BL.box(0,0,[1,48,48]);
    let result = QJ.sat,gridData;
    for (let x=startX;x<endX;x++) {
        for (let y=startY;y<endY;y++) {
            if (this.noPassDo) {
                if (!gameMap._noPassBox[x][y]) {
                    QJ.BL.setPostion(mapBox,x*48+24,y*48+24);
                    QJ.BL.judge(this.QJBody,mapBox);
                    if (result.result&&this.JudgeReBound(result,this.QJBody,mapBox)) return;
                }
            }
            if (this.regions.length>0) {
                gridData = gameMap.regionId(x,y);
                if (this.regions.includes(gridData)) {
                    QJ.BL.setPostion(mapBox,x*48+24,y*48+24);
                    QJ.BL.judge(this.QJBody,mapBox);
                    if (result.result&&this.JudgeReBound(result,this.QJBody,mapBox)) return;
                }
            }
            if (this.terrains.length>0) {
                gridData = gameMap.terrainTag(x,y);
                if (this.terrains.includes(gridData)) {
                    QJ.BL.setPostion(mapBox,x*48+24,y*48+24);
                    QJ.BL.judge(this.QJBody,mapBox);
                    if (result.result&&this.JudgeReBound(result,this.QJBody,mapBox)) return;
                }
            }
        }
    }
    //===============================================================
    if (this.WaitBaseOnSpeed==-1) return;
    if (this.WaitBaseOnSpeed>=0&&this.speed!=this.WaitBaseOnSpeed) return;
    this.target=dealTarget(this.data.Target);
    //===============================================================
    if (this.target.length!=0) {
        //===============================================================
        for (let i=0,l=this.target.length,character,extraCondition;i<l;i++) {
            if (typeof this.target[i] == "object") {
                character=QJ.BL.dealCharacter(this.target[i][0]);
                extraCondition=true;
            } else {
                character=QJ.BL.dealCharacter(this.target[i]);
                extraCondition=false;
            }
            if (!character) continue;
            if (QJ.BL.judge(this.QJBody,character.QJBody).result) {
                if (extraCondition) {
                    if (!eval(this.target[i][1])) continue;
                }
                this.actionAndDead(character);
                if (this.dead) break;
                continue;
            }
            let index=this.rememberEvent.indexOf(character);
            if (index!=-1) this.rememberEvent.splice(index,1);
        }
        //===============================================================
    }
    //===============================================================
    if (this.clearProjectile.length!=0) {
        for (let data1=this.clearProjectile,il=data1.length,i=0,
            data2=gameMap._mapBullets,data3=gameMap._mapBulletsName,
            idata1,idata2,idata3;i<il;i++) {
            idata1 = data1[i];
            idata3 = data3[idata1];
            if (!idata3) continue;
            for (let j of idata3) {
                idata2 = data2[j];
                if (idata2&&QJ.BL.judge(this.QJBody,idata2.QJBody).result) {
                    idata2.setDead();
                    if (this.data.cancalEachOther) {
                        for (let k=0,kdata=idata2.clearProjectile,kl=kdata.length;k<kl;k++) {
                            if (this.data.name.includes(kdata[k])) {
                                this.setDead();
                                break;
                            }
                        }
                    }
                    
                }
            }
        }
    }
    //===============================================================
    //console.timeEnd("collidedTime");
}
Game_QJBullet.prototype.colliedWith = function (id) {
    //===============================================================
    let character=QJ.BL.dealCharacter(id);
    if (!character) return;
    return QJ.BL.judge(this.QJBody,character.QJBody).result;
    //===============================================================
}
Game_QJBullet.prototype.setDymaticBitmap = function (name,data) {
    if (this.dbName!=name) {
        this.dymaticBitmap = data;
        this.dbName=name;
    }
}
Game_QJBullet.prototype.updateDymaticBitmap = function () {
    let dB = this.dymaticBitmap;
    if (dB) {
        dB[3]++;
        if (dB[3]==dB[4]) {
            dB[3]=0;
            dB[0]++;
            if (dB[0]==dB[1]) dB[0]=0;
        }
    }
}
Game_QJBullet.prototype.changeAttribute = function (attributeName,value) {
    if (attributeName=="Img") {
        this.bitmap = this.data.Img = value;
        let oldSprite = $gameMap.findBulletSprite(this);
        if (oldSprite) {
            oldSprite.bitmap = null;
        }
    } else if (attributeName=="MoveType") {
        this.data.initialRotation = this.rotation;
        this.moveType = this.data.MoveType = QJ.BL.dealMoveType(value,null);
    } else if (attributeName=="Target") {
        this.data.Target = value;
    } else if (attributeName=="Action") {
        this.action = this.data.Action = value;
    } if (attributeName=="CollisionBox") {
        this.boxType = this.data.CollisionBox = value;
        this.refreshBox();
    }
}
//=============================================================================
//Sprite_QJBullet
//=============================================================================
function Sprite_QJBullet() {
    this.initialize.apply(this, arguments);
};
Sprite_QJBullet.prototype = Object.create(Sprite_Base.prototype);
Sprite_QJBullet.prototype.constructor = Sprite_QJBullet;
Sprite_QJBullet.prototype.initialize = function(index) {
    Sprite_Base.prototype.initialize.call(this);
    this.o=$gameMap.bullet(index);
    //========================================================
    this.bitmapHex = this.o.data.Hex;
    this.blendMode = this.o.data.blendMode;
    this.setColorTone(this.o.data.Tone);
    this.setBlendColor(this.o.data.Blend);
    //========================================================
    this.update();
    //========================================================
};
Sprite_QJBullet.prototype.calculateFrameData = function(bitmap,bitmapName) {
    let frameImage=bitmapName.match(/\[[^\]]*\]/i);
    if (frameImage){
        let data=eval(frameImage[0]);
        if (data.length<3) data.splice(1,0,1);
        this.o.setDymaticBitmap(bitmapName,[0,data[0]*data[1],data[0],0,data[2],bitmap.width/data[0],bitmap.height/data[1]]);
        //总帧数计数   总帧数   宽度   单帧计数  单帧时间   宽度   高度
        this.refresDymaticBitmap();
    }
}
Sprite_QJBullet.prototype.refresDymaticBitmap = function() {
    let dB = this.o.dymaticBitmap;
    if (dB) {
        if (this.remFrameCount!=dB[0]) {
            this.remFrameCount=dB[0];
            this.setFrame(dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]);
        }
    }
}
Sprite_QJBullet.prototype.reloadBitmap = function() {
    let bitmapName = this.o.bitmap;
    let type = typeof bitmapName;
    if (type === "string") {
        let bitmap = ImageManager.loadBullet(bitmapName,this.bitmapHex);
        if (bitmap.width > 0 && bitmap.isReady()) {
            this.bitmap = bitmap;
            this.calculateFrameData(bitmap,bitmapName);
            let dB = this.o.dymaticBitmap;
            if (dB) {
                this.o.data.bitmapWidth = dB[6];
                this.o.data.bitmapHeight = dB[7];
            } else {
                this.o.data.bitmapWidth = this.bitmap.width;
                this.o.data.bitmapHeight = this.bitmap.height;
            }
        }
    } else if (type === "object") {
        if (bitmapName[0]==0) {
            this.bitmap=bitmapName[2];
            this.setFrame(bitmapName[3],bitmapName[4],bitmapName[5],bitmapName[6]);
        } else if (bitmapName[0]==1) {
            //[1,文字内容,文字颜色,文字字号,4文字排列方式,文本子弹最大宽度,文本子弹最大高度,7描边颜色,8描边粗细]
            let mw = bitmapName[5],mh = bitmapName[6],tx,ty,sx,sy;
            if (bitmapName[4]==0) this.bitmap=new Bitmap(mw,mh);
            else this.bitmap=new Bitmap(mh,mw);
            this.bitmap.fontSize = Number(bitmapName[3]);
            if (bitmapName[4]==0) {
                tx = this.bitmap.measureTextWidth(bitmapName[1]);
                ty = Number(bitmapName[3]);
                sx = (mw-tx)/2;
                sy = (mh-ty)/2;
            } else {
                tx = Number(bitmapName[3]);
                ty = Number(bitmapName[3])*bitmapName[1].length;
                sx = (mh-tx)/2;
                sy = (mw-ty)/2;
            }
            if (typeof bitmapName[2] === "object") {
                this.bitmap.textColor = QJ.BL.ColorGrad(this.bitmap,bitmapName[2][0],sx,sy,tx,ty,bitmapName[2][1]*Math.PI/180);
            } else {
                this.bitmap.textColor = bitmapName[2];
            }
            this.bitmap.fontItalic = false;
            if (typeof bitmapName[7] === "object") {
                this.bitmap.outlineColor = QJ.BL.ColorGrad(this.bitmap,bitmapName[7][0],sx,sy,tx,ty,bitmapName[7][1]*Math.PI/180);
            } else {
                this.bitmap.outlineColor = bitmapName[7];
            }
            this.bitmap.outlineWidth = bitmapName[8];
            if (bitmapName[4]==0) {
                this.bitmap.drawText(bitmapName[1],0,0,mw,mh,"center");
            } else if (bitmapName[4]==1) {
                this.bitmap.drawTextVerticalRow(bitmapName[1],0,0,mw,mh,"center");
            }
        } else if (bitmapName[0]==2) {
            this.bitmap=ImageManager.loadSystem('IconSet');
            let sx = bitmapName[1] % 16 * 32;
            let sy = Math.floor(bitmapName[1] / 16) * 32;
            this.setFrame(sx, sy, 32, 32);
        }
        this.o.data.bitmapWidth = this.bitmap.width;
        this.o.data.bitmapHeight = this.bitmap.height;
        this.o.setDymaticBitmap(null);
    }
}
Sprite_QJBullet.prototype.destroy = function() {
    if (this.parent && this._animationSprites) {
        for (let anim of this._animationSprites) {
            if (anim) {
                this.parent.removeChild(anim);
            }
        }
    }
    Sprite_Base.prototype.destroy.call(this);
    this.o = null;
}
Sprite_QJBullet.prototype.update = function() {
    //========================================
    Sprite_Base.prototype.update.call(this);
    this.updateBaseData();
    //========================================
    if (this.o.realDead) {
        this.destroy();
        return;
    } 
    if (!this.bitmap) {
        this.reloadBitmap();
        return;
    }
    //========================================
    this.refresDymaticBitmap();
    //========================================
    if (this.o.dead) {
        if (this.o.deadMode !== 3) {
            if (this.o.delayDelete>0) {
                this.o.delayDelete--;
            } else {
                if (this.o.opacity<=5) {
                    if (!this.isAnimationPlaying()&&this.children.length<=0) {
                        $gameMap.removeBullet(this.o.index);
                        return;
                    }
                }            
            }
        } 
    } else {
        if (!Graphics.isFPSTooLowQJ()) {
            this.updateParticles();
        }
    }
    //========================================
};
Sprite_QJBullet.prototype.updateAfterImage = function() {
    let afterImage = this.o.afterImage;
    if (afterImage.length>0) {
        //[颜色,初始不透明度,最大存在时间,宽度]
        //console.log(afterImage);
        let value = afterImage[0].get(),initO,initODe;
        if (!afterImage[1].isMode) {
            initO=afterImage[1].get()/255;
            initODe = 0;
            if (this.o.delayDelete>=0) initODe = (afterImage[2] - this.o.delayDelete)/afterImage[2]*initO;
        } else initODe = (1-(afterImage[2] - this.o.delayDelete)/afterImage[2]);
        if (value&&this.o.time>2) {
            let w=0;
            for (let ll=this.o.xyRem,i=ll.length-1,il=Math.max(0,i-afterImage[2]),mu=i-il,
                dx48=$gameMap.displayX()*48-48,dy48=$gameMap.displayY()*48,newO,newx,newy,
                gw=Graphics.width+96,gh=Graphics.height+96;i>il;i--) {
                w=afterImage[3].getTar(ll.length-1-i);
                if (!afterImage[3].isMode) w=w||this.width;
                if (!ll[i][3]) {
                    ll[i][3]=1;//原用于储存宽度，已抛弃。用1是为了防止多次更新。
                    ll[i][4]=Math.sqrt(
                        (ll[i][0]-ll[i-1][0])*(ll[i][0]-ll[i-1][0])+
                        (ll[i][1]-ll[i-1][1])*(ll[i][1]-ll[i-1][1]));
                    ll[i][5]=value;
                }
                if (afterImage[1].isMode) {
                    if (this.o.delayDelete>=0)  newO = afterImage[1].getTar(ll.length-1-i)/255*initODe;
                    else newO = afterImage[1].getTar(ll.length-1-i)/255;
                } else {
                    newO = (i-il)/mu*initO - initODe;
                }
                newx = ll[i][0]-dx48;
                newy = ll[i][1]-dy48;
                if (newO>0&&(newy>-48&&newy<gh&&newx>-48&&newx<gw)) {
                    this.particleParent.drawAfterImage(newx,newy,ll[i][2],ll[i][5],newO,w,
                        this.o.moveType[0]==6?(ll[i][4]+1):(ll[i][4]+(afterImage[4]?afterImage[4]:0.5)));
                }
            }
        }
    }
}
Sprite_QJBullet.prototype.updateParticles = function() {
    for (let i of this.o.Particles) {
        if (!i) continue;
        if (i.count<0) {
            let bitmap = ImageManager.loadBullet(i.img);
            if (!bitmap.isReady()) continue;
            let sx = this.o.screenShowXLast(1);
            let sy = this.o.screenShowYLast(1);
            let ex = this.o.screenShowXLast(0);
            let ey = this.o.screenShowYLast(0);
            let er = this.o.rotationMove;
            for (let j=0,jl=Math.max(Math.abs(sx-ex),Math.abs(sy-ey))/(-i.count),xd=(ex-sx)/jl,yd=(ey-sy)/jl,x=sx,y=sy;j<jl;j++) {
                this.particleParent.addChildrenAtId(new Sprite_QJY({
                    x:x,
                    y:y,
                    rotation:er
                },[2,i],this.o));
                x+=xd;
                y+=yd;
            }
        } else if (i.count==0) {
            let bitmap = ImageManager.loadBullet(i.img);
            if (!bitmap.isReady()) continue;
            for (let j=i.num;j>0;j--) {
                this.particleParent.addChildrenAtId(new Sprite_QJY(this,[2,i],this.o));
            }
            i.count = i.wait;
        } else i.count--;
    }
}
Sprite_QJBullet.prototype.updateBaseData = function() {
    this.x=this.o.screenShowX();
    this.y=this.o.screenShowY();
    this.rotation=this.o.rotation;
    this.scale.x = this.o.scaleX;
    this.scale.y = this.o.scaleY;
    this.anchor.x=this.o.anchorX;
    this.anchor.y=this.o.anchorY;
    this.opacity=this.o.opacity;
};
//=============================================================================
//Sprite_QJY
//=============================================================================
function Sprite_QJY() {
    this.initialize.apply(this, arguments);
};
Sprite_QJY.prototype = Object.create(PIXI.Sprite.prototype);
Sprite_QJY.prototype.constructor = Sprite_QJY;
Sprite_QJY.prototype.initialize = function(parent,data,buttle) {
    if (data[0]==1) this.QJParentid="qjy1"+Math.floor(data[5])+Math.floor(data[6])+data[7];
    else if (data[0]==2) this.QJParentid="qjy2"+data[1].img;
    this.baseTexture = textureSave[this.QJParentid]?
        textureSave[this.QJParentid]:this.createTexture(data);
    this.textureData = this.baseTexture?(new PIXI.Texture(this.baseTexture,new PIXI.Rectangle(0,0,0,0))):null;
    PIXI.Sprite.call(this,this.textureData);
    this.rotation = buttle.rotationMove;
    this.bitType = data[0];
    if (this.bitType==1) {
        if (buttle.moveType[0]==6) this.rotation = buttle.rM6S[2];
        else if (buttle.moveType[0]==5||buttle.moveType[0]==8) this.rotation = buttle.rotationMove;
        else this.rotation = parent.rotation;
        this._x=parent.x+$gameMap.displayX()*48;
        this._y=parent.y+$gameMap.displayY()*48;
        //=======================================
        this.opacity = data[4];
        this.perFade=Math.max(this.opacity/data[3],1);
        this.time=data[2];
        this.setFrame(0,0,data[5],data[6]);
    } else if (this.bitType==2) {
        this.data = data[1];
        let ox = eval(this.data.offsetX*Math.random()-this.data.offsetX/2);
        let oy = eval(this.data.offsetY*Math.random()-this.data.offsetY/2);
        this._x=parent.x+ox*Math.cos(parent.rotation)-oy*Math.sin(parent.rotation)+$gameMap.displayX()*48;
        this._y=parent.y-oy*Math.cos(parent.rotation)+ox*Math.sin(parent.rotation)+$gameMap.displayY()*48;
        this.rotation = parent.rotation + this.data.dir + Math.random()*this.data.dirOffset*2 - this.data.dirOffset;
        //=======================================
        this.opacity = ((this.data.opacityMax-this.data.opacityMin)*Math.random()+this.data.opacityMin)*255;
        this.perFade=Math.max(this.opacity/this.data.deadCount,1);
        this.time=this.data.max;
        this.sizeManager = [0,10,((this.data.scaleMax-this.data.scaleMin)*Math.random()+this.data.scaleMin)/10];
        this.setScale(this.sizeManager[0]*this.sizeManager[2]);
        let frameImage=this.data.img.match(/\[[^\]]*\]/i);
        if (frameImage){
            let data=eval(frameImage[0]);
            if (data.length<3) data.splice(1,0,1);
            data[0] = Number(data[0]);
            data[1] = Number(data[1]);
            this.dymaticBitmap=[0,data[0]*data[1],data[0],0,data[2],this.baseTexture.width/data[0],this.baseTexture.height/data[1]];
            let dB = this.dymaticBitmap;
            this.setFrame(dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]);
        } else {
            this.setFrame(0,0,this.baseTexture.width,this.baseTexture.height);
        }
        if (this.data.moveType.includes(";")) {
            this.mTFT=0;
            let d = this.data.moveType;
            if (d.substr(d.length-4)=="*t;0") {
                this.lineMove = true;
                this.moveType = [-Math.sin(this.rotation)*eval(d.substr(0,d.length-4)),
                    Math.cos(this.rotation)*eval(d.substr(0,d.length-4))];
            } else this.moveType=d.split(";");
        } else {
            this.mTFT=1;
            let d = this.data.moveType;
            if (d.substr(d.length-4)=="*t|0") {
                this.lineMove = true;
                this.moveType = [-Math.sin(this.rotation)*eval(d.substr(0,d.length-4)),
                    Math.cos(this.rotation)*eval(d.substr(0,d.length-4))];
            } else this.moveType=d.split("|");
        }
        if (this.moveType.length!=2) {
            this.moveTypeWrong();
            this.data.moveType=[0,0];
        }
    } 
    this.anchor.set(0.5,0.5);
    this.updateBaseData();
    numberQJY++;
};
Sprite_QJY.prototype.moveTypeWrong = function() {
    if (showWarn) console.warn("The moveType "+this.data.moveType+" of particle is wrong.");
}
Sprite_QJY.prototype.update = function() {
    this.updateBaseData();
    if (this.time<=0) {
        this.opacity-=this.perFade;
        if (this.opacity<=0) {
            this.parent.removeChild(this);
            numberQJY--;
            this.destroy();
            return;
        }
    }
    this.time--;
};
Sprite_QJY.prototype.setFrame = function(x,y,w,h) {
    this.textureData.frame = new PIXI.Rectangle(
        Math.floor(x),Math.floor(y),Math.floor(w),Math.floor(h));
};
Sprite_QJY.prototype.setScale = function(size) {
    this.scale = new PIXI.ObservablePoint(null,null,size,size);
};
Sprite_QJY.prototype.updateBaseData = function() {
    if (this.bitType==1) {
        this.alpha = this.opacity/255;
        this.x=this._x-$gameMap.displayX()*48;
        this.y=this._y-$gameMap.displayY()*48;
    } else if (this.bitType==2) {
        //=============================================
        if (this.sizeManager[0]<this.sizeManager[1]) {
            this.sizeManager[0]++;
            this.setScale(this.sizeManager[0]*this.sizeManager[2]);
        }
        //=============================================
        this.alpha = this.opacity/255;
        //=============================================
        if (this.lineMove) {
            let m=this.moveType,t=this.data.max-this.time;
            this.x=m[0]*t+this._x-$gameMap.displayX()*48;
            this.y=m[1]*t+this._y-$gameMap.displayY()*48;
        } else {
            let r=this.rotation,m=this.moveType,t=this.data.max-this.time,xL=0,yL=0;
            try{
                if (this.mTFT==0) {
                    xL=-1*Number(eval(m[0]));yL=Number(eval(m[1]));
                } else {
                    let length = -1*Number(eval(m[0])),rota=Number(eval(m[1]));
                    xL=length*Math.cos(rota);
                    yL=length*Math.sin(rota);
                }
            } catch(e) {
                this.moveTypeWrong();
                xL=0;
                yL=0;
            }
            if (!xL&&xL!=0) {xL=0;this.moveTypeWrong();}
            if (!yL&&yL!=0) {yL=0;this.moveTypeWrong();}
            this.x=xL*Math.sin(r)+ yL*Math.sin(r+Math.PI/2)+this._x-$gameMap.displayX()*48;
            this.y=-xL*Math.cos(r)-yL*Math.cos(r+Math.PI/2)+this._y-$gameMap.displayY()*48;
        }
        //=============================================
        if (this.dymaticBitmap) {
            let dB = this.dymaticBitmap;
            dB[3]++;
            if (dB[3]==dB[4]) {
                dB[3]=0;
                dB[0]++;
                if (dB[0]==dB[1]) dB[0]=0;
                this.setFrame(dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]);
            }
        }
        //=============================================
    }
};
Sprite_QJY.prototype.createTexture = function(data) {
    let lsCanvas = document.createElement('canvas');
    let lscontext = lsCanvas.getContext('2d');
    let lsBaseTexture = null;
    if (data[0]==1) {
        lsCanvas.width = data[5];
        lsCanvas.height = data[6];
        lsBaseTexture = new PIXI.BaseTexture(lsCanvas);
        lsBaseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
        lsBaseTexture.width = data[5];
        lsBaseTexture.height = data[6];
        lscontext.save();
        lscontext.fillStyle = data[7];
        lscontext.fillRect(0,0,data[5],data[6]);
        lscontext.restore();
    } else if (data[0]==2) {
        let bitmap = ImageManager.loadBullet(data[1].img),w=bitmap.width,h=bitmap.height;
        lsCanvas.width = w;
        lsCanvas.height = h;
        lsBaseTexture = new PIXI.BaseTexture(lsCanvas);
        lsBaseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
        lsBaseTexture.width = w;
        lsBaseTexture.height = h;
        lscontext.globalCompositeOperation = 'source-over';
        lscontext.drawImage(bitmap._canvas,0,0,w,h,0,0,w,h);
    }
    lsBaseTexture.update();
    textureSave[this.QJParentid] = lsBaseTexture;
    return lsBaseTexture;
};
//=============================================================================
//Game_QJLasernoPassDo
//=============================================================================
Game_QJLaser.prototype.initialize = function(data,index) {
    this.data=data;
    this.index=index;
    this.setBase();
};
Game_QJLaser.prototype.orginX = function() {
    return this.x+$gameMap.displayX()*48;
};
Game_QJLaser.prototype.orginY = function() {
    return this.y+$gameMap.displayY()*48;
};
Game_QJLaser.prototype.setBase = function() {
    //===============================================
    this.bulletMode = 1;
    this.z=this.data.z;
    this.rotationAuto = (this.data.RotationAuto-360)*Math.PI/180;
    //===============================================
    this.dead=false;//此子弹开始死亡，死亡后播放完动画且淡出后才真正消失。
    this.rememberEvent=[];//穿透时一个敌人只攻击一次，移出后才删除
    this.target=null;
    this.regions=this.data.Regions;
    this.terrains=this.data.Terrains;
    this.deadCount=this.data.DeadCount;
    this.action=this.data.Action;
    //===============================================
    this.rotation=this.data.initialRotation;
    this.lineList = [];
    //===============================================
    this.data.Name = (typeof this.data.name=="string")?this.data.name:
        (typeof this.data.Name=="string")?this.data.Name:"";
    this.name=this.data.Name.includes("|")?this.data.Name.split("|"):(this.data.Name?[this.data.Name]:[]);
    this.clearProjectile = this.data.clearProjectile.includes("|")?this.data.clearProjectile.split("|"):
        (this.data.clearProjectile?[this.data.clearProjectile]:[]);
    this.updateWait = [this.data.AtkWait,this.data.AtkWait];
    this.ReBound=this.data.ReBound+1;
    this.max = this.data.Max;
    this.time = 0;
    this.noPassDo = this.data.noPassDo;
    if (this.data.UpdateJS.length>0) this.UpdateJS = true;
    this.updateFadeValue();
    this.updateXYR(true);
};
Game_QJLaser.prototype.updateFadeValue = function() {
    this.opacity = this.data.Opacity.get();
    this.atkWidth = this.data.Width.get();
    this.scaleX = this.data.ScaleX.get()/100;
    this.MaxLength = this.data.MaxLength.get();
};
Game_QJLaser.prototype.updateXYR = function(ifInit) {
    let Math = window.Math;
    try{
        this.x = dealX(this.data.x,null,false);
        this.y = dealY(this.data.y,null,false);
        if (this.data.RotationAuto==-1||ifInit) {
            this.rotation = QJ.BL.dealInitialRotation(
                this.data.initialRotation,null,this.x,this.y);
        } else if (this.data.RotationAuto>0) {
            this.rotation+=this.rotationAuto;
        }
    } catch(e) {
        this.setDead();
        return;
    }
    this.lineList=[[this.x,this.y,this.rotation]];
    //console.time("bulletUpdate");
    for (let i=0,il=this.lineList,
        j=1,rbnum=0,
        x,y,
        lastX=-1,lastY=-1,
        dx=$gameMap.displayX(),dy=$gameMap.displayY(),
        w=Math.sin(this.rotation),h=-Math.cos(this.rotation);
        rbnum<this.ReBound;j++) {
        if (j>=this.MaxLength) {
            this.lineList.push([il[i][0]+j*w,il[i][1]+j*h,0]);
            break;
        }
        x=Math.floor((il[i][0]+j*w)/48+dx);
        y=Math.floor((il[i][1]+j*h)/48+dy);
        if (lastX==x&&lastY==y) continue;
        else {lastX=x;lastY=y;}
        //判断是否为反弹点
        if (!(this.regions.includes($gameMap.regionId(x,y))||
            this.terrains.includes($gameMap.terrainTag(x,y))||
            (this.noPassDo&&!$gameMap.noPassBoxLaser(x,y)))) continue;
        //找到对应格子的中心点
        x=(x-dx)*48+24;
        y=(y-dy)*48+24;
        let k=Math.tan(il[i][2]-Math.PI/2),b=il[i][1]-k*il[i][0];
        let judgeLsit;
        if (il[i][0]<=x+24&&il[i][0]>=x-24) {
            if (il[i][1]<y) judgeLsit=[8];
            else judgeLsit=[2];
        } else if (il[i][1]<=y+24&&il[i][1]>=y-24) {
            if (il[i][0]<x) judgeLsit=[4];
            else judgeLsit=[6];
        } else if (il[i][0]<x-24&&il[i][1]<y-24) {
            judgeLsit=[4,8];
        } else if (il[i][0]>x+24&&il[i][1]<y-24) {
            judgeLsit=[6,8];
        } else if (il[i][0]<x-24&&il[i][1]>y+24) {
            judgeLsit=[2,4];
        } else if (il[i][0]>x+24&&il[i][1]>y+24) {
            judgeLsit=[2,6];
        } else {
            this.lineList.push(il[i]);
            break;
        }
        let tx=-1,ty=-1,ro;
        for (let d=0;d<judgeLsit.length;d++) {
            if (judgeLsit[d]==2) {
                ty=y+24;
                tx=(ty-b)/k;
                ro=Math.PI-il[i][2];
                if (Math.abs(tx-x)<=24) break;
            } else if (judgeLsit[d]==4) {
                tx=x-24;
                ty=k*tx+b;
                ro=2*Math.PI-il[i][2];
                if (Math.abs(ty-y)<=24) break;
            } else if (judgeLsit[d]==6) {
                tx=x+24;
                ty=k*tx+b;
                ro=2*Math.PI-il[i][2];
                if (Math.abs(ty-y)<= 24) break;
            } else if (judgeLsit[d]==8) {
                ty=y-24;
                tx=(ty-b)/k;
                ro=Math.PI-il[i][2];
                if (Math.abs(tx-x)<=24) break;
            }
        }
        if (tx==-1&&ty==-1) {
            throw new Error("出错");
        }
        this.lineList.push([tx,ty,ro]);
        w=Math.sin(ro);
        h=-Math.cos(ro);
        i++;
        j=1;
        rbnum++;
    }
    //console.timeEnd("bulletUpdate");
};
Game_QJLaser.prototype.update = function () {
    //=======================
    if (this.dead) {
        if (this.deadCount==0) {
            $gameMap.removeBullet(this.index);
        } else {
            this.opacity-=this.perFade;
            if (this.opacity<=5) $gameMap.removeBullet(this.index);
        }
        return;
    }
    this.time++;
    switch(this.max[0]) {
        case 0:if (this.time>=this.max[1]) {this.setDead();}break;
        case 1:if ($gameSelfSwitches.value([this.max[1],this.max[2],this.max[3]])==this.max[4]) {this.setDead();}break;
        case 2:if ($gameSwitches.value(this.max[1])==this.max[2]) {this.setDead();}break;
        case 3:if (!!eval(this.max[1])==this.max[2]) {this.setDead();}break;
        default:this.setDead();break;
    }
    //=======================
    this.updateFadeValue();
    if (this.updateWait[0]==0) {
        this.updateAtk();
        this.updateWait[0]=this.updateWait[1];
    } else this.updateWait[0]--;
    this.updateClearProjectile();
    if (this.UpdateJS) eval(this.data.UpdateJS);
    //=======================
}
Game_QJLaser.prototype.updateAtk = function() {
    this.target=dealTarget(this.data.Target);
    let Math = window.Math;
    if (this.target.length>0) {
        //=================================================================
        let judgeBody=null;
        for (let ll=this.lineList,i=0,il=ll.length-1;i<il;i++) {
            let len=Math.sqrt((ll[i][0]-ll[i+1][0])*(ll[i][0]-ll[i+1][0])+
                (ll[i][1]-ll[i+1][1])*(ll[i][1]-ll[i+1][1]));
            if (len<=2) continue;
            judgeBody = QJ.BL.box(
                (ll[i][0]+ll[i+1][0])/2+$gameMap.displayX()*48,
                (ll[i][1]+ll[i+1][1])/2+$gameMap.displayY()*48,
                [1,this.atkWidth,len+2]);
            //+2是为了让激光能打到这条支线的末端点处的反弹事件。
            judgeBody.setAngle(calculateAngleByTwoPoint(
                ll[i][0],ll[i][1],
                ll[i+1][0],ll[i+1][1]));
            //=============================
            for (let i=0,l=this.target.length,character,extraCondition;i<l;i++) {
                if (typeof this.target[i] == "object") {
                    character=QJ.BL.dealCharacter(this.target[i][0]);
                    extraCondition=true;
                } else {
                    character=QJ.BL.dealCharacter(this.target[i]);
                    extraCondition=false;
                }
                if (!character||!character.QJBody) continue;
                if (QJ.BL.judge(judgeBody,character.QJBody).result) {
                    if (extraCondition) {
                        if (!eval(this.target[i][1])) continue;
                    }
                    QJ.BL.startAction(this,character);
                    continue;
                }
                let index=this.rememberEvent.indexOf(character);
                if (index!=-1) this.rememberEvent.splice(index,1);
            }
            //QJ.BL.sprite.aBody(judgeBody);
            //=============================
        }
        //=================================================================
    }
};
Game_QJLaser.prototype.updateClearProjectile = function() {
    //===============================================================
    if (this.clearProjectile.length>0) {
        //=================================================================
        let judgeBody=null;
        for (let ll=this.lineList,i=0,il=ll.length-1;i<il;i++) {
            let len=Math.sqrt((ll[i][0]-ll[i+1][0])*(ll[i][0]-ll[i+1][0])+
                (ll[i][1]-ll[i+1][1])*(ll[i][1]-ll[i+1][1]));
            if (len<=2) continue;
            judgeBody = QJ.BL.box(
                (ll[i][0]+ll[i+1][0])/2+$gameMap.displayX()*48,
                (ll[i][1]+ll[i+1][1])/2+$gameMap.displayY()*48,
                [1,this.atkWidth,len+2]);
            //+2是为了让激光能打到这条支线的末端点处的反弹事件。
            judgeBody.setAngle(calculateAngleByTwoPoint(
                ll[i][0],ll[i][1],
                ll[i+1][0],ll[i+1][1]));
            //=============================
            for (let data1=this.clearProjectile,il=data1.length,i=0,
                data2=$gameMap._mapBullets,data3=$gameMap._mapBulletsName,
                idata1,idata2,idata3;i<il;i++) {
                idata1 = data1[i];
                idata3 = data3[idata1];
                if (!idata3) continue;
                for (let j of idata3) {
                    idata2 = data2[j];
                    if (idata2&&QJ.BL.judge(judgeBody,idata2.QJBody).result) {
                        idata2.setDead();
                    }
                }
            }
            //QJ.BL.sprite.aBody(judgeBody);
            //=============================
        }
        //=================================================================
    }
    //===============================================================
};
Game_QJLaser.prototype.destroy = function() {
    this.judgeBody = null;
    this.data = null;
    this.realDead = true;
    this.dead = true;
};
Game_QJLaser.prototype.setDead = function() {
    this.dead = true;
    this.perFade=Math.max(this.opacity/this.deadCount,1);
};
Game_QJLaser.prototype.xs = function() {
    return 0;
};
Game_QJLaser.prototype.ys = function() {
    return 0;
};
Game_QJLaser.prototype.screenShowX = function() {
    return this.x - $gameMap.displayX()*48;
}
Game_QJLaser.prototype.screenShowY = function() {
    return this.y - $gameMap.displayY()*48;
}
//=============================================================================
//Sprite_QJLaser
//=============================================================================
function Sprite_QJLaser() {
    this.initialize.apply(this, arguments);
};
Sprite_QJLaser.prototype = Object.create(Sprite_Base.prototype);
Sprite_QJLaser.prototype.constructor = Sprite_QJLaser;
Sprite_QJLaser.prototype.initialize = function(index) {
    Sprite_Base.prototype.initialize.call(this);
    this.o=$gameMap.bullet(index);
    this.blendMode = this.o.data.blendMode;
    this.lineExpandMode = this.o.data.lineExpandMode;
    this.lineExpandScrollSpeed = this.o.data.lineExpandScrollSpeed||0;
    this.bitmapHex = this.o.data.Hex;
    //=================================================
    this.update();
    //=================================================
};
Sprite_QJLaser.prototype.reloadBitmap = function() {
    let bitmapName,bitmap,dB;
    if (!this.lineBit) {
        bitmapName = this.o.data.Img;
        bitmap = ImageManager.loadBullet(bitmapName,this.bitmapHex);
        if (bitmap.width > 0 && bitmap.isReady()) {
            this.lineBit = bitmap;
            this.lineBit.smooth = false;
            this.calculateFrameData(bitmap,bitmapName,"dymaticBitmapLine","refresDymaticBitmapLine");
            dB = this.dymaticBitmapLine;
            if (dB) {
                this.drawRectangleLine = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
            } else {
                this.drawRectangleLine = [0,0,bitmap.width,bitmap.height];
            }
        }
    }
    //=======================================================================================================================================
    if (!this.pointBit) {
        bitmapName = this.o.data.ImgPoint;
        bitmap = ImageManager.loadBullet(bitmapName,this.bitmapHex);
        if (bitmap.width > 0 && bitmap.isReady()) {
            this.pointBit = bitmap;
            this.pointBit.smooth = false;
            this.calculateFrameData(bitmap,bitmapName,"dymaticBitmapPoint","refresDymaticBitmapPoint");
            dB = this.dymaticBitmapPoint;
            if (dB) {
                this.drawRectanglePoint = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
            } else {
                this.drawRectanglePoint = [0,0,bitmap.width,bitmap.height];
            }
        }
    }
}
Sprite_QJLaser.prototype.calculateFrameData = function(bitmap,bitmapName,attributeName,refreshAttributeName) {
    let frameImage=bitmapName.match(/\[[^\]]*\]/i);
    if (frameImage){
        let data=eval(frameImage[0]);
        if (data.length<3) data.splice(1,0,1);
        //总帧数计数   总帧数   宽度   单帧计数  单帧时间   宽度   高度
        this[attributeName]=[0,data[0]*data[1],data[0],0,data[2],bitmap.width/data[0],bitmap.height/data[1]];
        this[refreshAttributeName](true);
    }
}
Sprite_QJLaser.prototype.refresDymaticBitmapLine = function(reset = false) {
    let dB = this.dymaticBitmapLine;
    dB[3]++;
    if (dB[3]==dB[4]) {
        dB[3]=0;
        dB[0]++;
        if (dB[0]==dB[1]) dB[0]=0;
        reset = true;
    }
    if (reset) {
        this.drawRectangleLine = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
    }
}
Sprite_QJLaser.prototype.refresDymaticBitmapPoint = function(reset = false) {
    let dB = this.dymaticBitmapPoint;
    dB[3]++;
    if (dB[3]==dB[4]) {
        dB[3]=0;
        dB[0]++;
        if (dB[0]==dB[1]) dB[0]=0;
        reset = true;
    }
    if (reset) {
        this.drawRectanglePoint = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
    }
}
Sprite_QJLaser.prototype.update = function() {
    //========================================
    if (this.o.realDead) {
        this.destroy();
        return;
    }
    if (!this.lineBit || !this.pointBit) {
        this.reloadBitmap();
        return;
    }
    //========================================
    Sprite_Base.prototype.update.call(this);
    //========================================
    if (!this.lineList) {
        //=================================================
        let tone = this.o.data.Tone;
        let blend = this.o.data.Blend;
        this.lineList = [];
        this.pointList = [];
        let bm=this.o.data.blendMode;
        for (let i=0,bit1,bit2;i<this.o.ReBound;i++) {
            bit1 = new Sprite(this.lineBit);
            if (this.lineExpandMode) {
                bit1 = new TilingSprite(this.lineBit);
            } else {
                bit1 = new Sprite(this.lineBit);
                bit1.setColorTone(tone);
                bit1.setBlendColor(blend);
                bit1.anchor.x=0.5;
            }
            bit1.anchor.y=1;
            bit2 = new Sprite(this.pointBit);
            bit1.blendMode = bm;
            bit2.blendMode = bm;
            bit2.setColorTone(tone);
            bit2.setBlendColor(blend);
            bit2.anchor.x=0.5;
            bit2.anchor.y=0.5;
            this.lineList.push(bit1);
            this.pointList.push(bit2);
            this.addChild(bit1);
            this.addChild(bit2);
        }
        let bit = new Sprite(this.pointBit);
        bit.blendMode = bm;
        bit.setColorTone(tone);
        bit.setBlendColor(blend);
        bit.anchor.x=0.5;
        bit.anchor.y=0.5;
        this.pointList.push(bit);
        this.addChild(bit);
        //=================================================
    }
    //========================================
    if (this.dymaticBitmapLine) this.refresDymaticBitmapLine();
    if (this.dymaticBitmapPoint) this.refresDymaticBitmapPoint();
    //========================================
    this.o.updateXYR();
    let scaleX = this.o.scaleX;
    let opacity = this.o.opacity;
    let ll = this.o.lineList;
    let drl = this.drawRectangleLine;
    let drp = this.drawRectanglePoint;
    //========================================
    //========================================
    for (let i=0,bit1,bit2,il=this.o.ReBound,lll=ll.length;i<il;i++) {
        //==========================
        bit1 = this.lineList[i];
        bit2 = this.pointList[i];
        //==========================
        bit2.x = ll[i][0];
        bit2.y = ll[i][1];
        bit2.setFrame(drp[0],drp[1],drp[2],drp[3]);
        bit2.scale.x = scaleX;
        bit2.rotation = ll[i][2];
        bit2.opacity = opacity;
        //==========================
        if (!ll[i+1]) {
            bit1.visible = false;
            bit2.visible = false;
            for (let j=i+1;j<il;j++) {
                this.lineList[j].visible = false;
                this.pointList[j].visible = false;
            }
            break;
        } else {
            bit1.visible = true;
            bit2.visible = true;
        }
        //==========================
        bit1.setFrame(drl[0],drl[1],drl[2],drl[3]);
        bit1.rotation = ll[i][2];
        bit1.scale.x = scaleX;
        if (this.lineExpandMode) {
            bit1.move(
                ll[i][0]-drl[2]/2*Math.sin(bit1.rotation+Math.PI/2),
                ll[i][1]+drl[2]/2*Math.cos(bit1.rotation+Math.PI/2),
                drl[2],
                Math.sqrt((ll[i][0]-ll[i+1][0])*(ll[i][0]-ll[i+1][0])+(ll[i][1]-ll[i+1][1])*(ll[i][1]-ll[i+1][1]))
            );
            if (this.lineExpandScrollSpeed) {
                bit1.origin.y += this.lineExpandScrollSpeed;
            }
        } else {
            bit1.x = ll[i][0];
            bit1.y = ll[i][1];
            bit1.scale.y = Math.sqrt(
                (ll[i][0]-ll[i+1][0])*(ll[i][0]-ll[i+1][0])+
                (ll[i][1]-ll[i+1][1])*(ll[i][1]-ll[i+1][1])
            )/drl[3];
        }
        bit1.opacity = opacity;
        //==========================
    }
    //==========================
    let bit = this.pointList[this.pointList.length-1];
    bit.x = ll[ll.length-1][0];
    bit.y = ll[ll.length-1][1];
    bit.setFrame(drp[0],drp[1],drp[2],drp[3]);
    bit.rotation = ll[ll.length-2][2];
    bit.scale.x = scaleX;
    bit.opacity = opacity;
    //========================================
};
Sprite_QJLaser.prototype.destroy = function() {
    Sprite_Base.prototype.destroy.call(this);
    this.o = null;
}
//========================================================
//=============================================================================
//Game_QJLaser
//=============================================================================
Game_QJTwoPoint.prototype.initialize = function(data,index) {
    this.data=data;
    this.index=index;
    this.setBase();
};
Game_QJTwoPoint.prototype.orginX = function() {
    return this.x+$gameMap.displayX()*48;
};
Game_QJTwoPoint.prototype.orginY = function() {
    return this.y+$gameMap.displayY()*48;
};
Game_QJTwoPoint.prototype.setBase = function() {
    //===============================================
    this.bulletMode = 2;
    this.z=this.data.z;
    this.bitmap = this.data.Img;
    this.scaleX = this.data.scaleX/100;
    //===============================================
    this.opacity = this.data.Opacity.get();
    this.dead=false;
    this.deadCount=this.data.DeadCount;
    this.max = this.data.Max;
    this.time = 0;
    this.perFade=Math.max(this.opacity/this.deadCount,1);
    //===============================================
    this.rotation=this.data.initialRotation;
    this.twoPointLength=0;
    //===============================================
    this.action=this.data.Action;
    this.target=null;
    this.updateWait = [this.data.AtkWait,this.data.AtkWait];
    this.rememberEvent = [];
    this.data.Name = (typeof this.data.name=="string")?this.data.name:
        (typeof this.data.Name=="string")?this.data.Name:"";
    this.name=this.data.Name.includes("|")?this.data.Name.split("|"):(this.data.Name?[this.data.Name]:[]);
    this.clearProjectile = this.data.clearProjectile.includes("|")?this.data.clearProjectile.split("|"):
        (this.data.clearProjectile?[this.data.clearProjectile]:[]);
    this.ExtraRotation=this.data.ExtraRotation*Math.PI/180;
    //===============================================
    this.xyData = [];
    GroupRandomList = []
    GroupRandomReLoad = false;
    this.xyData[0]=QJ.BL.calculateGAndGR(this.data.x1);
    GroupRandomReLoad = true;
    this.xyData[1]=QJ.BL.calculateGAndGR(this.data.y1);
    GroupRandomList = []
    GroupRandomReLoad = false;
    this.xyData[2]=QJ.BL.calculateGAndGR(this.data.x2);
    GroupRandomReLoad = true;
    this.xyData[3]=QJ.BL.calculateGAndGR(this.data.y2);
    if (!this.xyData[0]||!this.xyData[1]||!this.xyData[2]||!this.xyData[3]) {
        this.setDead();
        return;
    }
    //===============================================
    if (typeof this.data.lineMode == "string") {
        let detail = this.data.lineMode.match(/([A-Z]*)\[([^\]]*)\]/i);
        if (detail[1]=="L") {
            this.data.lineMode = ["L"];
        } else if (detail[1]=="C"){
            detail = detail[2].split(",");
            this.data.lineMode = ["C",Number(detail[0])*Math.PI/180,
                detail[1]?Number(detail[1]):0,
                detail[2]?Number(detail[2]):1];
        } else if (detail[1]=="B"){
            detail = detail[2].split(",");
            this.data.lineMode = ["B",new QJFrame(null,detail[0]?detail[0]:'9',0),
                detail[1]?Number(detail[1]):100,
                detail[2]?Number(detail[2]):20,
                detail[3]?Number(detail[3]):40,
                detail[4]?Number(detail[4]):10];
        }
    }
    //===============================================
    this.updateXYR();
    this.updateFadeValue();
    //===============================================
};
Game_QJTwoPoint.prototype.updateFadeValue = function() {
    this.opacity = this.data.Opacity.get();
    this.atkWidth = this.data.Width.get();
    this.scaleX = this.data.ScaleX.get()/100;
};
Game_QJTwoPoint.prototype.updateXYR = function() {
    this.x = dealX(this.xyData[0],null,true);
    this.y = dealY(this.xyData[1],null,true);
    this.tarX = dealX(this.xyData[2],null,true);
    this.tarY = dealY(this.xyData[3],null,true);
    if (this.x==null||this.y==null||this.tarX==null||this.tarY==null) {
        //directly delete.
        this.setDead();
        $gameMap.removeBullet(this.index);
        return;
    }
    this.rotation = calculateAngleByTwoPoint(this.x,this.y,this.tarX,this.tarY);
    this.twoPointLength=Math.sqrt((this.x-this.tarX)*(this.x-this.tarX)+(this.y-this.tarY)*(this.y-this.tarY));
    if (this.ExtraRotation) {
        this.rotation+=this.ExtraRotation;
        this.tarX=this.x+Math.sin(this.rotation)*this.twoPointLength;
        this.tarY=this.y-Math.cos(this.rotation)*this.twoPointLength;
    }
};
Game_QJTwoPoint.prototype.update = function () {
    //=======================
    this.updateXYR();
    if (this.dead) {
        if (this.deadCount==0) {
            $gameMap.removeBullet(this.index);
        } else {
            this.opacity-=this.perFade;
            if (this.opacity<=5) $gameMap.removeBullet(this.index);
        }
        return;
    }
    this.time++;
    switch(this.max[0]) {
        case 0:if (this.time>=this.max[1]) {this.setDead();}break;
        case 1:if ($gameSelfSwitches.value([this.max[1],this.max[2],this.max[3]])==this.max[4]) {this.setDead();}break;
        case 2:if ($gameSwitches.value(this.max[1])==this.max[2]) {this.setDead();}break;
        case 3:if (!!eval(this.max[1])==this.max[2]) {this.setDead();}break;
        default:this.setDead();break;
    }
    //=======================
    this.updateFadeValue();
    if (this.updateWait[0]==0) {
        this.updateAtk();
        this.updateWait[0]=this.updateWait[1];
    } else this.updateWait[0]--;
    this.updateClearProjectile();
    //=======================
}
Game_QJTwoPoint.prototype.destroy = function() {
    this.judgeBody = null;
    this.data = null;
    this.realDead = true;
    this.dead = true;
};
Game_QJTwoPoint.prototype.setDead = function() {
    this.dead = true;
};
Game_QJTwoPoint.prototype.xs = function() {
    return this.x;
};
Game_QJTwoPoint.prototype.ys = function() {
    return this.y;
};
Game_QJTwoPoint.prototype.screenShowX = function() {
    return this.x;// - $gameMap.displayX()*48;
}
Game_QJTwoPoint.prototype.screenShowY = function() {
    return this.y;// - $gameMap.displayY()*48;
}
Game_QJTwoPoint.prototype.updateAtk = function() {
    this.target=dealTarget(this.data.Target);
    let judgeBody;
    if (this.data.AtkRange>0) {
        //=============================
        judgeBody = QJ.BL.box(
            this.tarX+$gameMap.displayX()*48,
            this.tarY+$gameMap.displayY()*48,
            [0,this.data.AtkRange]);
        this.judgeAtk(judgeBody);
    } else {
        //=============================
        if (this.data.lineMode[0]=="L") {
            let len = this.twoPointLength;
            if (len<=2) return;
            judgeBody = QJ.BL.box(
                this.x+$gameMap.displayX()*48,
                this.y+$gameMap.displayY()*48,
                [1,this.atkWidth,len]);
            judgeBody.translate(0,-len/2);
            judgeBody.setAngle(this.rotation);
            this.judgeAtk(judgeBody);
        } else if (this.remQuadraticCurveData) {
            if (this.data.lineMode[0]=="C"||this.data.lineMode[0]=="B") {
                let dx48 = $gameMap.displayX()*48;
                let dy48 = $gameMap.displayY()*48;
                for (let i of this.remQuadraticCurveData) {
                    judgeBody = QJ.BL.box(i.x+dx48,i.y+dy48,[1,this.atkWidth,i.l]);
                    judgeBody.translate(0,-i.l/2);
                    judgeBody.setAngle(i.r);
                    this.judgeAtk(judgeBody);
                }
            }
        }
    }
    //=============================
};
Game_QJTwoPoint.prototype.judgeAtk = function(judgeBody) {
    //===============================================================
    for (let i=0,l=this.target.length,character,extraCondition;i<l;i++) {
        if (typeof this.target[i] == "object") {
            character=QJ.BL.dealCharacter(this.target[i][0]);
            iextraCondition=true;
        } else {
            character=QJ.BL.dealCharacter(this.target[i]);
            extraCondition=false;
        }
        if (!character||!character.QJBody) continue;
        if (QJ.BL.judge(judgeBody,character.QJBody).result) {
            if (extraCondition) {
                if (!eval(this.target[i][1])) continue;
            }
            QJ.BL.startAction(this,character);
            continue;
        }
        let index=this.rememberEvent.indexOf(character);
        if (index!=-1) this.rememberEvent.splice(index,1);
    }
    //QJ.BL.sprite.aBody(judgeBody);
    //===============================================================
};
Game_QJTwoPoint.prototype.updateClearProjectile = function() {
    //===============================================================
    if (this.clearProjectile.length>0) {
        //=================================================================
        let judgeBody;
        if (this.data.AtkRange>0) {
            //=============================
            judgeBody = QJ.BL.box(
                this.tarX+$gameMap.displayX()*48,
                this.tarY+$gameMap.displayY()*48,
                [0,this.data.AtkRange]);
        } else {
            //=============================
            let len = this.twoPointLength;
            if (len<=2) return;
            judgeBody = QJ.BL.box(
                this.x+$gameMap.displayX()*48,
                this.y+$gameMap.displayY()*48,
                [1,this.atkWidth,len]);
            judgeBody.translate(0,-len/2);
            judgeBody.setAngle(this.rotation);
        }
        //=================================================================
        for (let data1=this.clearProjectile,il=data1.length,i=0,
            data2=$gameMap._mapBullets,data3=$gameMap._mapBulletsName,
            idata1,idata2,idata3;i<il;i++) {
            idata1 = data1[i];
            idata3 = data3[idata1];
            if (!idata3) continue;
            for (let j of idata3) {
                idata2 = data2[j];
                if (idata2&&QJ.BL.judge(judgeBody,idata2.QJBody).result) {
                    idata2.setDead();
                }
            }
        }
        //QJ.BL.sprite.aBody(judgeBody);
        //=================================================================
    }
    //===============================================================
};
//=============================================================================
//Sprite_QJLaser
//=============================================================================
function Sprite_QJTwoPoint() {
    this.initialize.apply(this, arguments);
};
Sprite_QJTwoPoint.prototype = Object.create(Sprite_Base.prototype);
Sprite_QJTwoPoint.prototype.constructor = Sprite_QJTwoPoint;
Sprite_QJTwoPoint.prototype.initialize = function(index) {
    Sprite_Base.prototype.initialize.call(this);
    this.o=$gameMap.bullet(index);
    this.blendMode = this.o.data.blendMode;
    this.anchor.x=0.5;
    this.anchor.y=1;
    this.opacity=this.o.opacity;
    this.scale.x=this.o.scaleX;
    this.bitmapHex = this.o.data.Hex;
    this.setColorTone(this.o.data.Tone);
    this.setBlendColor(this.o.data.Blend);
    //=========================================================================
    this.update();
    //=========================================================================
};
Sprite_QJTwoPoint.prototype.reloadBitmap = function(bit) {
    if (!this.loadLineBitmapOK) {
        let bitmapName = this.o.data.Img;
        if (typeof bitmapName === "string" && bitmapName.length>0) {
            bitmap = ImageManager.loadBullet(bitmapName,this.bitmapHex);
            if (bitmap.width > 0 && bitmap.isReady()) {
                this.generateBitmap(bitmap);
                this.calculateFrameData(bitmap,bitmapName,"dymaticBitmap","refresDymaticBitmap");
                dB = this.dymaticBitmap;
                if (dB) {
                    this.remHeight = dB[6];
                    this.drawRectangle = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
                } else {
                    this.remHeight = bitmap.height;
                    this.drawRectangle=[0,0,bitmap.width,bitmap.height];
                }
                this.loadLineBitmapOK = true;
            }
        } else {
            this.loadLineBitmapOK = true;
        }
    }
    if (!this.loadPointBitmapOK) {
        let bitmapName = this.o.data.ImgPoint;
        if (typeof bitmapName === "string" && bitmapName.length>0) {
            bitmap = ImageManager.loadBullet(bitmapName,this.bitmapHex);
            if (bitmap.width > 0 && bitmap.isReady()) {
                this.generateBitmapPoint(bitmap);
                this.calculateFrameData(bitmap,bitmapName,"dymaticBitmapPoint","refresDymaticBitmapPoint");
                dB = this.dymaticBitmapPoint;
                if (dB) {
                    this.drawRectanglePoint = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
                } else {
                    this.drawRectanglePoint=[0,0,bitmap.width,bitmap.height];
                }
                this.loadPointBitmapOK = true;
            }
        } else {
            this.loadPointBitmapOK = true;
        }
    }
}
Sprite_QJTwoPoint.prototype.calculateFrameData = function(bitmap,bitmapName,attributeName,refreshAttributeName) {
    let frameImage=bitmapName.match(/\[[^\]]*\]/i);
    if (frameImage){
        let data=eval(frameImage[0]);
        if (data.length<3) data.splice(1,0,1);
        //总帧数计数   总帧数   宽度   单帧计数  单帧时间   宽度   高度
        this[attributeName]=[0,data[0]*data[1],data[0],0,data[2],bitmap.width/data[0],bitmap.height/data[1]];
        this[refreshAttributeName](true);
    }
}
Sprite_QJTwoPoint.prototype.generateBitmap = function(bit) {
    if (this.o.data.lineMode[0]=="L") {
        let sprite = this._lineSprite = new Sprite(bit);
        sprite.anchor.x = 0.5;
        sprite.anchor.y = 1;
        this.addChild(sprite);
    } else if (this.o.data.lineMode[0]=="C"||this.o.data.lineMode[0]=="B") {
        this.remBitForQC = bit;
    }
}
Sprite_QJTwoPoint.prototype.generateBitmapPoint = function(bit) {
    let sprite1 = this._pointSprite1 = new Sprite(bit);
    sprite1.anchor.x = 0.5;
    sprite1.anchor.y = 0.5;
    let sprite2 = this._pointSprite2 = new Sprite(bit);
    sprite2.anchor.x = 0.5;
    sprite2.anchor.y = 0.5;
    this.addChild(sprite1);
    this.addChild(sprite2);
}
Sprite_QJTwoPoint.prototype.refresDymaticBitmapPoint = function(change = false) {
    let dB = this.dymaticBitmapPoint;
    dB[3]++;
    if (dB[3]==dB[4]) {
        dB[3]=0;
        dB[0]++;
        if (dB[0]==dB[1]) dB[0]=0;
        change = true;
    }
    if (change) {
        this.drawRectanglePoint = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
    }
    let de = this.drawRectanglePoint;
    this._pointSprite1.setFrame(de[0],de[1],de[2],de[3]);
    this._pointSprite2.setFrame(de[0],de[1],de[2],de[3]);
}
Sprite_QJTwoPoint.prototype.refresDymaticBitmap = function(change = false) {
    let dB = this.dymaticBitmap;
    dB[3]++;
    if (dB[3]==dB[4]) {
        dB[3]=0;
        dB[0]++;
        if (dB[0]==dB[1]) dB[0]=0;
        change = true;
    }
    if (change) {
        this.drawRectangle = [dB[0]%dB[2]*dB[5],Math.floor(dB[0]/dB[2])*dB[6],dB[5],dB[6]];
    }
    if (this.o.data.lineMode[0]=="L") {
        let de = this.drawRectangle;
        this._lineSprite.setFrame(de[0],de[1],de[2],de[3]);
    }
}
Sprite_QJTwoPoint.prototype.update = function() {
    //========================================
    if (this.o.realDead) {
        this.destroy();
        return;
    }
    if (!this.loadLineBitmapOK || !this.loadPointBitmapOK) {
        this.reloadBitmap();
        return;
    }
    //========================================
    Sprite_Base.prototype.update.call(this);
    //========================================
    if (this._lineSprite) {
        if (this.o.data.lineMode[0]=="L") {
            this._lineSprite.x=this.o.screenShowX();
            this._lineSprite.y=this.o.screenShowY();
            this._lineSprite.rotation=this.o.rotation;
            this._lineSprite.opacity=this.o.opacity;
            this._lineSprite.scale.y=this.o.twoPointLength/this.remHeight;
        }
        if (this.dymaticBitmap&&this.drawRectangle) {
            this.refresDymaticBitmap();
        }
    } else if (this.o.data.lineMode[0]=="C"||this.o.data.lineMode[0]=="B") {
        if (this.dymaticBitmap&&this.drawRectangle) {
            this.refresDymaticBitmap();
        }
    }
    if (this.dymaticBitmapPoint&&this.drawRectanglePoint) {
        this.refresDymaticBitmapPoint();
    }
    if (this._pointSprite1) {
        this._pointSprite1.x = this.o.x;
        this._pointSprite1.y = this.o.y;
        this._pointSprite1.rotation=this.o.rotation;
        this._pointSprite1.opacity=this.o.opacity;
    }
    if (this._pointSprite2) {
        this._pointSprite2.x = this.o.tarX;
        this._pointSprite2.y = this.o.tarY;
        this._pointSprite2.rotation=-this.o.rotation;
        this._pointSprite2.opacity=this.o.opacity;
    }
    //========================================
};
Sprite_QJTwoPoint.prototype.updateQuadraticCurve = function() {
    if (!this.o || this.o.realDead) return;
    if (this.o.data.lineMode[0]!="C"||!this.remBitForQC) return;
    let sx = this.o.x,sy = this.o.y;
    let ex = this.o.tarX,ey = this.o.tarY;
    let rotation = this.o.rotation;
    let opacity = this.o.opacity/255;
    let quadraticCurve = this.o.data.lineMode;
    let bit = this.remBitForQC;
    let length = this.o.twoPointLength;
    let rect = this.drawRectangle;
    let draw = this.particleParent.drawQuadraticCurve.bind(this.particleParent);
    let cx = sx+length*Math.sin(rotation+(rotation>Math.PI?quadraticCurve[1]:(-quadraticCurve[1])));
    let cy = sy-length*Math.cos(rotation+(rotation>Math.PI?quadraticCurve[1]:(-quadraticCurve[1])));
    let x,y,r,l,lx,ly;
    if (!this.o.remQuadraticCurveData) {
        this.o.remQuadraticCurveData = [];
    }
    this.o.remQuadraticCurveData.length = 0;
    let rem = this.o.remQuadraticCurveData;
    let delta = Math.floor(rect[3]/length*quadraticCurve[3]*100)/100;
    let pi_divide_2 = Math.PI/2;
    let atan2 = Math.atan2;
    let sqrt = Math.sqrt;
    let min = Math.min;
    for (let t=0;true;t=min(t+delta,1)) {
        x = (1-t)*(1-t)*sx+2*t*(1-t)*cx+t*t*ex;
        y = (1-t)*(1-t)*sy+2*t*(1-t)*cy+t*t*ey;
        r = atan2((y-ly),(x-lx))-pi_divide_2;
        l = sqrt((ly-y)*(ly-y)+(lx-x)*(lx-x))+quadraticCurve[2];
        rem.push({x:x,y:y,r:r,l:l});
        draw(lx+48,ly,r,bit,opacity,rect[2],l,rect);
        lx = x;
        ly = y;
        if (t>=1) {
            break;
        }
    }
}
Sprite_QJTwoPoint.prototype.updateBrokenLine = function() {
    if (!this.o || this.o.realDead) return;
    if (this.o.data.lineMode[0]!="B"||!this.remBitForQC) return;
    let sx = this.o.x,sy = this.o.y;
    let ex = this.o.tarX,ey = this.o.tarY;
    let rotation = this.o.rotation;
    let sin = Math.sin(rotation);
    let cos = -Math.cos(rotation);
    let opacity = this.o.opacity/255;
    let lineMode = this.o.data.lineMode;
    let bit = this.remBitForQC;
    let length = this.o.twoPointLength;
    let rect = this.drawRectangle;
    let draw = this.particleParent.drawQuadraticCurve.bind(this.particleParent);
    let x,y,r,l,lx,ly;
    if (!this.o.remQuadraticCurveData) {
        this.o.remQuadraticCurveData = [];
    }
    this.o.remQuadraticCurveData.length = 0;
    let rem = this.o.remQuadraticCurveData;
    let pi_divide_2 = Math.PI/2;
    let sqrt = Math.sqrt,atan2 = Math.atan2,min = Math.min,round = Math.round,ranFun = QJ.BL.pseudoRandom;
    let minValue = lineMode[3];
    let maxValue = lineMode[4];
    let disturbance = lineMode[5];
    let range = lineMode[2];
    for (let randomNum=ranFun(lineMode[1].get()),nowLength=0;true;) {
        if (nowLength==0||nowLength==length) {
            x = sx+sin*nowLength;
            y = sy+cos*nowLength;
        } else {
            x = sx+sin*nowLength-cos*(randomNum/233280.0*range-range/2+Math.random()*disturbance-disturbance/2);
            y = sy+cos*nowLength+sin*(randomNum/233280.0*range-range/2+Math.random()*disturbance-disturbance/2);
        }
        r = atan2((y-ly),(x-lx))-pi_divide_2;
        l = sqrt((ly-y)*(ly-y)+(lx-x)*(lx-x));
        rem.push({x:x,y:y,r:r,l:l});
        draw(lx+48,ly,r,bit,opacity,rect[2],l,rect);
        if (nowLength>=length) {
            break;;
        }
        randomNum=ranFun(randomNum);
        nowLength = min(nowLength + round(minValue + (maxValue - minValue) * randomNum  / 233280.0),length);
        randomNum=ranFun(randomNum);
        lx = x;
        ly = y;
    }
}
Sprite_QJTwoPoint.prototype.destroy = function() {
    Sprite_Base.prototype.destroy.call(this);
    this.o = null;
}
//=============================================================================
//
//=============================================================================
/*if (!this._testRope) {
    let sprite = this._testRope = new PIXI.Rope(new PIXI.Texture(QJ.BL.createBaseTexture(bit)),rem);
    this.addChild(sprite);
}*/
/*if (!this.particleParent.AIBitmap) this.particleParent.generateBitmap();
let frame = new QJFrame(null,"0|#00ff00~10/#ffffff~10/#00ffb2",1);
for (let length=20,i=length,color;i>=0;i--) {
    color = frame.get();
    if (i==length) {
        this.particleParent.AIBitmap.drill_GL_drawBessel(sx+48,sy,cx+48,cy,ex+48,ey,i,color);
    } else {
        this.particleParent.AIBitmap.drill_GL_drawBessel_Step(sx+48,sy,cx+48,cy,ex+48,ey,i,color);
    }
}*/
/*Bitmap.prototype.drill_GL_drawBessel_Step = function(x1,y1,x2,y2,x3,y3,width,color){
    var context = this._context;
    context.save();
    context.strokeStyle = color;
    context.lineWidth = width;
    context.lineJoin = 'round';
    context.beginPath();
    context.moveTo(x1,y1);
    context.quadraticCurveTo(x2,y2,x3,y3);
    context.stroke();
    context.restore();
};
Bitmap.prototype.drill_GL_drawBessel = function(x1,y1,x2,y2,x3,y3,width,color){
    var context = this._context;
    context.save();
    context.strokeStyle = color;
    context.lineWidth = width;
    context.lineJoin = 'round';
    context.shadowColor = color;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.beginPath();
    context.shadowBlur = width;
    context.moveTo(x1,y1);
    context.quadraticCurveTo(x2,y2,x3,y3);
    context.stroke();
    context.restore();
};*/
//=============================================================================
//
//=============================================================================
QJ.BL.box = function(x,y,boxType){
    let body = null;
    if (boxType[0]==0) {
        body = new SATCircle(new SATVectorMV(x,y),boxType[1]);
        body.type = 0;
        body.dia = boxType[1];
    } else if (boxType[0]==1) {
        body = new SATPolygon(
            new SATVectorMV(x,y), [
            new SATVectorMV(-boxType[1]/2,-boxType[2]/2),
            new SATVectorMV(+boxType[1]/2,-boxType[2]/2),
            new SATVectorMV(+boxType[1]/2,+boxType[2]/2),
            new SATVectorMV(-boxType[1]/2,+boxType[2]/2)
        ]);
        body.type = 1;
        body.w = boxType[1];
        body.h = boxType[2];
        body.dl = Math.atan(body.w/body.h);//Diagonal line angle
        body.dia = Math.sqrt(body.w*body.w+body.h*body.h)/2;//Diagonal length
    }
    return body;
};
QJ.sat = new SATResponse();
QJ.BL.judge = function(bodyA,bodyB){
    QJ.sat.clear();
    if (bodyA.type==0&&bodyB.type==0) {
        QJ.sat.result = SATtestCircleCircle(bodyA,bodyB,QJ.sat);
    } else if (bodyA.type==1&&bodyB.type==1) {
        QJ.sat.result = SATtestPolygonPolygon(bodyA,bodyB,QJ.sat);
    } else if (bodyA.type==1&&bodyB.type==0) {
        QJ.sat.result = SATtestPolygonCircle(bodyA,bodyB,QJ.sat);
    }  else if (bodyA.type==0&&bodyB.type==1) {
        QJ.sat.result = SATtestCirclePolygon(bodyA,bodyB,QJ.sat);
    } 
    return QJ.sat;
};
QJ.BL.setPostion = function(body,x,y){
    //body.setOffset(new SAT.Vector(x,y));
    body.pos.x = x;
    body.pos.y = y;
};
//=============================================================================
//Call Page
//=============================================================================
QJ.BL.CallEvent = function(value,listvalue,extraValue){
    if ($gameMap.event(value)) 
    $gameMap.event(value).steupTarPageQB(listvalue,extraValue);
};
const QB_Game_Event_initialize = Game_Event.prototype.initialize;
Game_Event.prototype.initialize = function(mapId, eventId) {
    this._forceInterpreterQB = new Array();
    QB_Game_Event_initialize.call(this,mapId, eventId);
};
Game_Event.prototype.steupTarPageQB = function(value,extraValue) {
    if (!!this.event().pages[value-1]) {
        let newPage = new Game_InterpreterForceQBEvent(value-1,extraValue);
        this._forceInterpreterQB.push(newPage);
        if (!newPage.isRunning()) {
            newPage.setup(this.event().pages[value-1].list,this._eventId);
        }
    }
};
const QB_Game_Event_updateParallel = Game_Event.prototype.updateParallel;
Game_Event.prototype.updateParallel = function() {
    QB_Game_Event_updateParallel.call(this);
    for (let i=this._forceInterpreterQB.length-1;i>=0;i--) {
        this._forceInterpreterQB[i].update();
        if (this._forceInterpreterQB[i]._hasOverActionQB) {
            this._forceInterpreterQB.splice(i,1);
        }
    }
};
//=============================================================================
//Game_InterpreterForceQBEvent
//=============================================================================
Game_InterpreterForceQBEvent.prototype = Object.create(Game_Interpreter.prototype);
Game_InterpreterForceQBEvent.prototype.constructor = Game_InterpreterForceQBEvent;
Game_InterpreterForceQBEvent.prototype.initialize = function(pageIndex,extraValue) {
    Game_Interpreter.prototype.initialize.call(this,0);
    this.pageIndex=pageIndex;
    this.BP = extraValue;
};
Game_InterpreterForceQBEvent.prototype.terminate = function() {
    Game_Interpreter.prototype.terminate.call(this);
    this._hasOverActionQB = true;
    this.BP = null;
};
//=============================================================================
//Common Event
//=============================================================================
QJ.BL.callCommonEvent = function(listvalue,eid,bp,bulletCanUseData){
    $gameMap.steupTarPageQB(listvalue,eid,bp,bulletCanUseData);
};
const QB_Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
    QB_Game_Map_initialize.call(this);
    this._forceInterpreterQB = new Array();
};
Game_Map.prototype.steupTarPageQB = function(value,eid,bp,bulletCanUseData) {
    if (!!$dataCommonEvents[value])
    this._forceInterpreterQB.push(new Game_InterpreterForceQBCommonEvent(value,eid,bp,bulletCanUseData));
};
Game_Map.prototype.clearTarPage = function() {
    this._forceInterpreterQB = [];
    for (let i of this.events()) {
        i._forceInterpreterQB = [];
    }
};
//=============================================================================
//Game_InterpreterForceQBCommonEvent
//=============================================================================
Game_InterpreterForceQBCommonEvent.prototype = Object.create(Game_Interpreter.prototype);
Game_InterpreterForceQBCommonEvent.prototype.constructor = Game_InterpreterForceQBCommonEvent;
Game_InterpreterForceQBCommonEvent.prototype.initialize = function(id,eid,bp,bulletCanUseData) {
    Game_Interpreter.prototype.initialize.call(this,0);
    this.commonEventId=id;
    this.EID=eid;
    this.BP=bp;
    this.bullet = bulletCanUseData;
};
Game_InterpreterForceQBCommonEvent.prototype.terminate = function() {
    $gameMap._forceInterpreterQB.splice($gameMap._forceInterpreterQB.indexOf(this),1);
    Game_Interpreter.prototype.terminate.call(this);
};
//=============================================================================
//Deal Detail Data.
//=============================================================================
QJ.BL.dealInitialRotation=function(data,event,x,y){
    //======================================
    if (!isNaN(Number(data))) return data*Math.PI/180;
    //======================================
    if (data[0]=="S") {
        data=data.substr(2,data.length-3);
        try{
            data=eval(data);
            if (isNaN(Number(data))) return null;
            return Number(data);
        } catch(e) {
            return null;
        }
    }
    //======================================
    try{
    //======================================
    data=data.replace(/PD(\[\])*/ig,(d)=>{
        return QJ.BL.calculateAngleByDirection($gamePlayer.direction())*180/Math.PI;
    });
    data=data.replace(/EV\[([^\],]*)\]/ig,(d,s1)=>{
        return calculateAngleByTwoPoint(x,y,
            $gameMap.event($gameVariables.value(Number(s1))).boxScreenSubRealX(),
            $gameMap.event($gameVariables.value(Number(s1))).boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/ESV\[([^\],]*),([^\],]*),([^\],]*)\]/ig,(d,s1,s2,s3)=>{
        s1 = Number(s1)?Number(s1):$gameMap.mapId();
        s2 = Number(s2);
        let valueData = $gameSelfVariables.value([s1,s2,s3]);
        return calculateAngleByTwoPoint(x,y,
            $gameMap.event(valueData).boxScreenSubRealX(),
            $gameMap.event(valueData).boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/XM\[([^\],]*)\]YM\[([^\],]*)\]/ig,(d,s1,s2)=>{
        return calculateAngleByTwoPoint(x,y,
            Number(s1)*tileSize+24 + $gameMap.displayX(),
            Number(s2)*tileSize+24 + $gameMap.displayY())*180/Math.PI;
    });
    //======================================
    data=data.replace(/P(\[\])+/ig,(d)=>{
        return calculateAngleByTwoPoint(x,y,
            $gamePlayer.boxScreenSubRealX(),$gamePlayer.boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/M(\[\])+/ig,(d)=>{
        return calculateAngleByTwoPoint(x,y,
            mouseX + $gameMap.displayX(),mouseY + $gameMap.displayY())*180/Math.PI;
    });
    data=data.replace(/D\[([^\],]+)\]/ig,(d,s1)=>{
        return QJ.BL.calculateAngleByDirection(
            s1==0?event.direction():$gameMap.event(Number(s1)).direction())*180/Math.PI;
    });
    data=data.replace(/E\[([^\],]+)\]/ig,(d,s1)=>{
        return calculateAngleByTwoPoint(x,y,
            $gameMap.event(Number(s1)).boxScreenSubRealX(),
            $gameMap.event(Number(s1)).boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/G\[([^\],]+)\]/ig,(d,s1)=>{
        let eventData = $gameMap.event(QJ.BL.getMinEventId(x+$gameMap.displayX()*48,y+$gameMap.displayY()*48,s1));
        return calculateAngleByTwoPoint(x,y,
            eventData.boxScreenSubRealX(),eventData.boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/N\[([^\],]+)\]/ig,(d,s1)=>{
        let eventData = $gameMap.event(QJ.BL.getMinEventIdNobi(x+$gameMap.displayX()*48,y+$gameMap.displayY()*48,s1));
        return calculateAngleByTwoPoint(x,y,
            eventData.boxScreenSubRealX(),eventData.boxScreenSubRealY())*180/Math.PI;
    });
    data=data.replace(/X\[([^\],]+)\]Y\[([^\],]+)\]/ig,(d,s1,s2)=>{
        return calculateAngleByTwoPoint(x,y,Number(s1),Number(s2))*180/Math.PI;
    });
    data=data.replace(/B\[([^\]]+),([^\]]+)\]/ig,(d,s1,s2)=>{
        let tar = $gameMap.bullet(Number(s1));
        return tar?tar.showRotationLastMove(Number(s2)):null;
    });
    //======================================
    data=eval(data);
    if (isNaN(Number(data))) return null;
    return Number(data)*Math.PI/180;
    //======================================
    } catch(e) {return null;}
    //======================================
};
let GroupRandomList = [];
let GroupRandomReLoad = false;
QJ.BL.calculateGAndGR=function(data){
    //======================================
    if (!isNaN(Number(data))) return data;
    //======================================
    try{
        let broken = false;
        data=data.replace(/G\[([^\],]+),([^,]+),([^,]+),([^\],]+),([^\],]+)\]/ig,(d,s1,s2,s3,s4,s5)=>{
            s2=dealX(s2,null,true);
            s3=dealY(s3,null,true);
            let eventData = QJ.BL.getMinEventId(
                Number(s2)+$gameMap.displayX()*48,
                Number(s3)+$gameMap.displayY()*48,s1,Number(s5),Number(s4));
            if (!eventData) broken = true;
            return eventData>0?("E["+eventData+"]"):0;
        });
        data=data.replace(/G\[([^\],]+),([^,]+),([^,]+)\]/ig,(d,s1,s2,s3)=>{
            s2=dealX(s2,null,true);
            s3=dealY(s3,null,true);
            let eventData = QJ.BL.getMinEventId(
                Number(s2)+$gameMap.displayX()*48,
                Number(s3)+$gameMap.displayY()*48,s1);
            if (!eventData) broken = true;
            return eventData>0?("E["+eventData+"]"):0;
        });
        if (broken) return null;
        data=data.replace(/GR\[([^\],]+)\]/ig,(d,s1)=>{
            if (GroupRandomReLoad) {
                return "E["+GroupRandomList.shift()+"]";
            } else {
                let eventsData = QJ.BL.getGroupId(s1);
                let eventData = eventsData[Math.floor(Math.random()*eventsData.length)];
                if (!eventData) broken = true;
                GroupRandomList.push(eventData);
                return eventData>0?("E["+eventData+"]"):0;
            }
        });
        data=data.replace(/GRR\[([^\],]+),([^,]+),([^,]+),([^\],]+)\]/ig,(d,s1,s2,s3,s4)=>{
            if (GroupRandomReLoad) {
                return "E["+GroupRandomList.shift()+"]";
            } else {
                s2=dealX(s2,null,true);
                s3=dealY(s3,null,true);
                let eventsData = QJ.BL.getGroupIdInRange(s1,Number(s2),Number(s3),Number(s4));
                let eventData = eventsData[Math.floor(Math.random()*eventsData.length)];
                if (!eventData) broken = true;
                GroupRandomList.push(eventData);
                return eventData>0?("E["+eventData+"]"):0;
            }
        });
        if (broken) return null;
        return data;
    } catch(e) {
        console.log(e);
        return null;
    }
    //======================================
};
let dealX = QJ.BL.dealX = function(data,event,fastRead){
    //======================================
    if (!isNaN(Number(data))) return data;
    //======================================
    if (!fastRead&&data[0]=="S") {
        data=data.substr(2,data.length-3);
        try{
            data=eval(data);
            if (isNaN(Number(data))) return null;
            return Number(data);
        } catch(e) {
            return null;
        }
    }
    //======================================
    try{
    //======================================
    data=data.replace(/P(\[\])+/ig,(d)=>{
        return $gamePlayer.vehicle()?$gamePlayer.vehicle().boxScreenSubRealX():$gamePlayer.boxScreenSubRealX();
    });
    data=data.replace(/M(\[\])+/ig,(d)=>{
        return mouseX;
    });
    data=data.replace(/E\[([^\],]+)\]/ig,(d,s1)=>{
        let tar = Number(s1)==0?event:$gameMap.event(Number(s1));
        return tar.boxScreenSubRealX();
    });
    data=data.replace(/B\[([^\],]+)\]/ig,(d,s1)=>{
        let tar = $gameMap.bullet(Number(s1));
        return tar?tar.screenShowX():null;
    });
    data=data.replace(/B\[([^\]]+),([^\]]+)\]/ig,(d,s1,s2)=>{
        let tar = $gameMap.bullet(Number(s1));
        return tar?tar.screenShowXLast(Number(s2)):null;
    });
    //======================================
    data=eval(data);
    if (data==null||isNaN(Number(data))||(!data&&data!=0)) return null;
    return Number(data);
    //======================================
    } catch(e) {return null;}
    //======================================
};
let dealY = QJ.BL.dealY = function(data,event,fastRead){
    //======================================
    if (!isNaN(Number(data))) return data;
    //======================================
    if (!fastRead&&data[0]=="S") {
        data=data.substr(2,data.length-3);
        try{
            data=eval(data);
            if (isNaN(Number(data))) return null;
            return Number(data);
        } catch(e) {
            return null;
        }
    }
    //======================================
    try{
    //======================================
    data=data.replace(/P(\[\])+/ig,(d)=>{
        return $gamePlayer.vehicle()?$gamePlayer.vehicle().boxScreenSubRealY():$gamePlayer.boxScreenSubRealY();
    });
    data=data.replace(/M(\[\])+/ig,(d)=>{
        return mouseY;
    });
    data=data.replace(/E\[([^\],]+)\]/ig,(d,s1)=>{
        let tar = Number(s1)==0?event:$gameMap.event(Number(s1));
        return tar.boxScreenSubRealY();
    });
    data=data.replace(/B\[([^\],]+)\]/ig,(d,s1)=>{
        let tar = $gameMap.bullet(Number(s1));
        return tar?tar.screenShowY():null;
    });
    data=data.replace(/B\[([^\]]+),([^\]]+)\]/ig,(d,s1,s2)=>{
        let tar = $gameMap.bullet(Number(s1));
        return tar?tar.screenShowYLast(Number(s2)):null;
    });
    //======================================
    data=eval(data);
    if (data==null||isNaN(Number(data))||(!data&&data!=0)) return null;
    return Number(data);
    //======================================
    } catch(e) {return null;}
    //======================================
};
QJ.BL.dealData0InXY = function(data,event){
    data=data.replace(/E\[([^\],]+)\]/ig,(d,s1)=>{
        let detail = parseInt(s1);
        if (detail==0) return "E["+(event?event.eventId():0)+"]";
        else return "E["+detail+"]";
    });
    return data;
};
QJ.BL.dealMax=function(data,event){
    //======================================
    if (typeof data=="number"||!isNaN(Number(data))) {
        data = Number(data);
        return [0,data==-1?999999999:data];
    } else if (data[0]=="S"&&data[1]=="S") {
        let detail = data.substr(3,data.length-4).split(",");
        return [1,$gameMap.mapId(),Number(detail[0])==0?event._eventId:Number(detail[0]),
            detail[1],eval(detail[2])];
    } else if (data[0]=="S") {
        let detail = data.substr(2,data.length-3).split(",");
        return [2,Number(detail[0]),eval(detail[1])];
    } else {
        let detail = data.substr(2,data.length-3);
        return [3,detail,true];
    }
    return null;
    //======================================
};
QJ.BL.dealZ=function(data,event){
    if (typeof data === "number") return "C";
    else if (data[0]=="T") return "T";
    else if (data[0]=="M") return "M";
    else if (data[0]=="C") return "C";
    else if (data[0]=="P") return "P";
    else return null;
};
QJ.BL.dealMoveType = function(movetype,event) {
    if (movetype[0]=="S") return [0];
    //======================================
    try{
    if (movetype[0]=="F") {
        let data=movetype.substr(2,movetype.length-3);
        if (data.includes(";")) {
            data=data.split(";");
            if (data.length!=2) return null;
            return [8,0,data[0],data[1]];
        } else {
            data=data.split("|");
            if (data.length!=2) return null;
            return [8,1,data[0],data[1]];
        }
    }
    if (movetype[0]=="C") {
        if (movetype[1]=="I") {
            let data = movetype.match(/CI\[([0-9-]*),([0-9-.]*),([0-9-.]*)\]/);
            if (!data) data = movetype.match(/CI\[([0-9-]*),([0-9-.]*),([0-9-.]*),([0-9-.]*)\]/);
            return [10,Number(data[1]),Number(data[2]),Number(data[3]),data[4]?Number(data[4]):0];
        } else {
            return [9];
        }
    }
    if (movetype[0]=="B") {
        let data=(movetype.substr(2,movetype.length-3)).split(",");
        if (Number(data[0])==0) data[0] = event._eventId;
        else data[0] = Number(data[0]);
        if (!data) return null;
        return [5,data[0],data[1],data[2],data[3],data[4]
                         ,data[5],data[6],data[7],data[8]];
    }
    if (movetype[0]=="Q"&&movetype[1]=="P") {
        let data=(movetype.substr(3,movetype.length-4)).split(",");
        if (!data) return null;
        return [6,Number(eval(data[0])),Number(eval(data[1])),
                  Number(eval(data[2])),Number(eval(data[3]))];
    }
    if (movetype[0]=="Q"&&movetype[1]=="B") {
        let data=(movetype.substr(3,movetype.length-4)).split(",");
        if (!data) return null;
        let mayId = parseInt(data[0]);
        return [11,isNaN(mayId)?data[0]:(mayId==0?(event?event.eventId():-2):mayId)];
    }
    if (movetype[0]!="T") return null;
    //======================================
    if (movetype[1]=="E"&&movetype[2]=="V") {
        let data=movetype.match(/\[[^\]]*\]/i);
        if (!data) return null;
        let detail=eval(data[0]);
        return [3,Number(detail[0]),$gameVariables.value(Number(detail[1]))];
    }
    if (movetype[1]=="E") {
        let data=movetype.match(/\[[^\]]*\]/i);
        if (!data) return null;
        let detail=eval(data[0]);
        return [2,Number(detail[0]),Number(detail[1])];
    }
    if (movetype[1]=="P") {
        let data=movetype.match(/\[[^\]]*\]/i);
        if (!data) return null;
        let detail=eval(data[0]);
        return [1,Number(detail[0])];
    }
    if (movetype[1]=="G") {
        let data=(movetype.substr(3,movetype.length-4)).split(",");
        if (!data) return null;
        return [4,Number(data[0]),String(data[1])];
    }
    if (movetype[1]=="N") {
        let data=(movetype.substr(3,movetype.length-4)).split(",");
        if (!data) return null;
        return [7,Number(data[0]),String(data[1])];
    }
    return null;
    //======================================
    } catch(e) {return null;}
    //======================================
};
let dealTarget = QJ.BL.dealTarget = function(data) {
    let tarList=new Array(),detail,detailName,ifExtraCondition;
    //======================================
    try{
    //======================================
    for (let i of data) {
        if (typeof i == "object") {
            detailName = i[0];
            ifExtraCondition = true;
        } else {
            detailName = i;
            ifExtraCondition = false;
        }
        if (detailName[0]=="E"&&detailName[1]=="V") {
            detail=eval(detailName.match(/\[[^\]]*\]/i)[0]);
            if (!detail||isNaN(Number(detail[0]))) continue;
            if (ifExtraCondition) {
                tarList.push([$gameVariables.value(Number(detail[0])),i[1]]);
            } else {
                tarList.push($gameVariables.value(Number(detail[0])));
            }
        } else if (detailName[0]=="E") {
            detail=eval(detailName.match(/\[[^\]]*\]/i)[0]);
            if (!detail||isNaN(Number(detail[0]))) continue;
            if (ifExtraCondition) {
                tarList.push([Number(detail[0]),i[1]]);
            } else {
                tarList.push(Number(detail[0]));
            }
        } else if (detailName[0]=="P") {
            if (ifExtraCondition) {
                tarList.push([-1,i[1]]);
            } else {
                tarList.push(-1);
            }
        } else if (detailName[0]=="G") {
            detail=detailName.substr(2,detailName.length-3);
            if (!detail) continue;
            if (ifExtraCondition) {
                tarList=tarList.concat(QJ.BL.getGroupId(detail).map((data)=>{
                    return [data,i[1]];
                }));
            } else {
                tarList=tarList.concat(QJ.BL.getGroupId(detail));
            }
        } else if (detailName.includes("Nobi")) {
            detail=detailName.substr(5,detailName.length-6);
            if (!detail) continue;
            if (ifExtraCondition) {
                tarList=tarList.concat(QJ.BL.getCommentId("["+detail+"]").map((data)=>{
                    return [data,i[1]];
                }));
            } else {
                tarList=tarList.concat(QJ.BL.getCommentId("["+detail+"]"));
            }
        }
    }
    return tarList;
    //======================================
    } catch(e) {return null;}
    //======================================
};
QJ.BL.dealTime=function(time){
    if (typeof time=="number") return time;
    try{
    if (time[0]=="S"&&time[1]=="S") {
        let detail=time.substr(3,time.length-4).split(",");
        return [0,detail[0],!!eval(detail[1])];
    } else if (time[0]=="S") {
        let detail=time.substr(2,time.length-3).split(",");
        return [1,Number(detail[0]),!!eval(detail[1])];
    } else if (time[0]=="T") {
        let detail=time.substr(2,time.length-3);
        return [2,detail];
    }
    return [0,""];
    } catch(e) {return [0,""];}
};
QJ.BL.dealTimeBoolean=function(time,event){
    if (typeof time=="number") return time<=0;
    try{
    if (time[0]==0) {
        return $gameSelfSwitches.value([$gameMap.mapId(),event._eventId,time[1]]) == time[2];
    } else if (time[0]==1) {
        return $gameSwitches.value(time[1])==time[2];
    } else if (time[0]==2) {
        return !!eval(time[1]);
    }
    return false;
    } catch(e) {return false;}
};
QJ.BL.startAction=function(bullet,tarCharacter,ifPierce = false){
    let dataList=bullet.action,eid=0;
    if (tarCharacter) {
        if (tarCharacter==$gamePlayer) eid=-1;
        else if (tarCharacter._eventId>0) eid=tarCharacter._eventId;
    }
    let bulletX = bullet.screenShowX(),bulletY = bullet.screenShowY(),bulletR = bullet.rotation;
    if (typeof dataList === "string") dataList=[dataList];
    for (let data of dataList) {
    if (typeof data === "object") {
        if (data[0]=="C") {
            QJ.BL.callCommonEvent(Number(data[1]),eid,data,{
                x:bulletX,
                y:bulletY,
                r:bulletR,
                extra:bullet.commonEventExtraData||{},
                bullet:bullet,
                ifPierce:ifPierce
            });
        } else if (data[0]=="CP"&&eid!=0) {
            QJ.BL.CallEvent(eid,Number(data[1]),JsonEx.makeDeepCopy(data));
        }
    } else if (data[0]=="C"&&data[1]=="P"&&eid!=0) {
        let detail=eval(data.match(/\[[^\]]*\]/i)[0]);
        if (!detail) return;
        if (isNaN(Number(detail[0]))) return;
        if (Number(detail[0])<=0||!Number.isInteger(detail[0])) return;
        QJ.BL.CallEvent(eid,Number(detail[0]));
    } else if (data[0]=="C") {
        let detail=eval(data.match(/\[[^\]]*\]/i)[0]);
        if (!detail) return;
        if (isNaN(Number(detail[0]))) return;
        if (Number(detail[0])<=0||!Number.isInteger(detail[0])) return;
        QJ.BL.callCommonEvent(Number(detail[0]),eid,detail,{
            x:bulletX,
            y:bulletY,
            r:bulletR,
            extra:bullet.commonEventExtraData||{},
            bullet:bullet,
            ifPierce:ifPierce
        });
    } else if (data[0]=="S"&&data[1]=="S"&&eid!=0) {
        let detail=data.substr(3,data.length-4).split(",");
        let key = [$gameMap.mapId(),eid,detail[0]];
        let result=detail[1]=="true"?true:false;
        $gameSelfSwitches.setValue(key,result);
    } else if (data[0]=="S") {
        let detail=eval(data.match(/\[[^\]]*\]/i)[0]);
        if (!detail) return;
        if (isNaN(Number(detail[0]))) return;
        if (Number(detail[0])<=0||!Number.isInteger(detail[0])) return;
        $gameSwitches.setValue(Number(detail[0]),detail[1]);
    } else if (data[0]=="E") {
        if (tarCharacter._eventId>0) tarCharacter.erase();
    } else if (data[0]=="T") {
        let detail=data.substr(2,data.length-3);
        eval(detail);
    }
    }
};
QJ.BL.DirectAction = function(x,y,box,action,target,lastAtkEvent) {
    //==========================================
    let event=QJ.BL.getEvent();
    GroupRandomList = []
    GroupRandomReLoad = false;
    let xo = dealX(x,event);
    GroupRandomReLoad = true;
    let yo = dealY(y,event);
    x = xo+$gameMap.displayX()*tileSize;
    y = yo+$gameMap.displayY()*tileSize;
    let body=QJ.BL.box(x,y,QJ.BL.dealCollisionBox(box));
    QJ.BL.sprite.aBody(body);
    //==========================================
    target = dealTarget(target);
    let hasAtkEvent = [];
    lastAtkEvent = lastAtkEvent||[];
    //==========================================
    for (let i=0,l=target.length;i<l;i++) {
        let character=null;
        character=QJ.BL.dealCharacter(target[i]);
        if (!character) continue;
        if (lastAtkEvent.includes(character)) continue;
        if (QJ.BL.judge(body,character.QJBody).result) {
            hasAtkEvent.push(character);
            QJ.BL.startAction({
                action:action,
                screenShowX:()=>{return xo;},
                screenShowY:()=>{return yo;},
                rotation:0
            },character);
        }
    }
    return hasAtkEvent;
}
QJ.BL.dealParticles = function(data){
    if (typeof data !== "object"||data.length==null||data.length==undefined) return [];
    for (let i in data) {
        if (typeof data[i] == "string") {
            try{data[i] = JsonEx.parse(data[i]);}catch(e){data[i] = null;}
        } else if (typeof data[i] !== "object") data[i] = null;
        if (!data[i]) continue;
        let list = {
            img:null,
            offsetX:0,
            offsetY:0,
            dir:Math.PI,
            dirOffset:Math.PI/6,
            max:30,
            deadCount:60,
            opacityMin:0.5,
            opacityMax:1,
            scaleMin:0.5,
            scaleMax:1.5,
            moveType:"-8*t;0",
            wait:2,
            num:1
        };
        for (let j in data[i]) list[j] = data[i][j];
        list.count = list.wait;
        data[i] = list;
    };
    return data;
};
//=============================================================================
//Shoot order.
//=============================================================================
QJ.BL.Shooter_FlameThrower = function(data,minScale,maxScale,offsetDir,num) {
    let bullet = {
        Img:"fire[11,5]",
        Max:80,
        DeadCount:40,
        AnchorX:0.5,
        AnchorY:0.5
    };
    for (let i in data) bullet[i] = data[i];
    for (let i=0;i<num;i++) {
        let size = minScale+Math.random()*(maxScale-minScale);
        bullet.initialRotation=(data.initialRotation!=undefined?data.initialRotation:"PD[]")+"+"+(Math.random()*offsetDir*2-offsetDir);
        bullet.CollisionBox="R["+size+","+size+"]";
        bullet.scaleX=size;
        bullet.scaleY=size;
        QJ.BL.Shoot(bullet);
    }
}
QJ.BL.Shooter_Gain = function(data,type,id,num) {
    data.x = "E[0]";
    data.y = "E[0]";
    data.Target = ["P[]"];
    data.Max = 90+60*60*60;
    data.initialRotation = 60*Math.random()-30+(Math.random()>0.5?90:270);
    data.RotationAuto = 0;
    data.CollisionBox = "R[32,32]";
    let item;
    if (type==3||type=="gold") {
        data.Img=[2,id];
        if (Imported.MOG_TreasurePopup&&((Moghunter.trpopup_GoldVisible) === "true"&&$gameSystem._trspupVisible)) {
            if (num>0||(num<0&&Moghunter.trpopup_LostItemVisible)) 
                data.Action = ["T[$gameParty.gainGold("+num+");"+
                "$gameSystem._trspupData.push(["+null+","+num+",bullet.screenShowX(),bullet.screenShowY()]);]"];
        } else data.Action = ["T[$gameParty.gainGold("+num+");]"];
    } else {
        if (type==0||type=="item") item="$dataItems["+id+"]";
        else if (type==1||type=="weapon") item="$dataWeapons["+id+"]";
        else if (type==2||type=="armor") item="$dataArmors["+id+"]";
        else {
            console.log("投射物品的指令参数错误。");
            return;
        }
        data.Img=[2,eval(item).iconIndex];
        if (Imported.MOG_TreasurePopup&&$gameSystem._trspupVisible) {
            if (num>0||(num<0&&Moghunter.trpopup_LostItemVisible)) 
                data.Action = ["T[$gameParty.gainItem("+item+","+num+");"+
                "$gameSystem._trspupData.push(["+item+","+num+",bullet.screenShowX(),bullet.screenShowY()]);]"];
        } else data.Action = ["T[$gameParty.gainItem("+item+","+num+");]"];
    }
    data.UpdateJS = 
        "if (this.moveType[4]==0&&this.QJBody) {"+
        "    if (this.itemOffset==undefined) this.itemOffset = 30;"+
        "    this.itemOffset--;"+
        "    if (this.itemOffset>=15) this.anchorY+=0.1/15;"+
        "    else this.anchorY-=0.1/15;"+
        "    if (this.itemOffset==0) this.itemOffset=30;"+
        "}";
    data.AtkRange = 0;
    data.WaitBaseOnSpeed = -2;
    QJ.BL.Shooter_HandGrenade(data,16,5,5);
}
QJ.BL.Shooter_CharacterAtk = function(character,data,of,arc) {
    //[ox2,oy2,ox4,oy4,ox6,oy6,ox8,oy8],[r1,r2,num,l]
    //====================================
    let tar = character==-1?$gamePlayer:
        (character==0?QJ.BL.getEvent():$gameMap.event(character));
    if (!tar) return;
    //====================================
    let orginRotation = QJ.BL.calculateAngleByDirection(tar.direction())*180/Math.PI;
    let ofx=of[tar.direction()-2],ofy=of[tar.direction()-1];
    //====================================
    if (arc) {
        let delta = (arc[1] - arc[0]) / arc[2];
        for (let i=arc[0];i<arc[1];i+=delta) {
            let bullet = {
                initialRotation:orginRotation+i+(Math.random()-0.5)*arc[3],
                x:tar.boxScreenSubX()+ofx,
                y:tar.boxScreenSubY()+ofy
            };
            for (let i in data) bullet[i] = data[i];
            QJ.BL.Shoot(bullet);
        }
    } else {
        let bullet = {
            initialRotation:orginRotation,
            x:tar.boxScreenSubX()+ofx,
            y:tar.boxScreenSubY()+ofy
        };
        for (let i in data) bullet[i] = data[i];
        QJ.BL.Shoot(bullet);
    }
    //====================================
}
QJ.BL.Shooter_P = function(data,r,speed,roSpeed,number,rotation,x,y,edgeNum) {
    if (edgeNum<2) {
        QJ.BL.error(" edgeNum "+edgeNum+" ");
        return;
    }
    if (number<2) {
        QJ.BL.error(" edgeNum "+number+" ");
        return;
    }
    //====================================
    let calRo=(a,b,c)=>{
        return Math.asin(a*Math.sin(c)/Math.sqrt(a*a+b*b-2*a*b*Math.cos(c)));
    };
    let calLo=(a,b,c)=>{
        return Math.sqrt(a*a+b*b-2*a*b*Math.cos(c));
    }
    //====================================
    for (let i=0,il=number-1,ilm=Math.max(Math.sqrt(2-2*Math.cos(2*Math.PI/edgeNum))*r/(number-1),1),
        c=Math.PI*(0.5-1/edgeNum),fan=false,halfil=(il+1)/2;i<il;i++) {
        if (i>halfil) fan=true;
        QJ.BL.Shooter_C(data,calLo(i*ilm,r,c),speed,roSpeed,edgeNum,rotation,x,y,
            fan?(-calRo((il-i)*ilm,r,c)):calRo(i*ilm,r,c));
    }
    //====================================
}
QJ.BL.Shooter_C = function(data,r,speed,roSpeed,number,rotation,x,y,extraRo) {
    //====================================
    let makeText=(r,rs,n,m,s)=>{
        return "F[-"+s+"*t+"+
        r+"*Math.sin(t/"+
        rs+"+2*Math.PI*"+
        n+"/"+m+"+"+extraRo+");0+"+
        r+"*Math.cos(t/"+
        rs+"+2*Math.PI*"+
        n+"/"+m+"+"+extraRo+")]";
    };
    //====================================
    let event=QJ.BL.getEvent();
    let ro = QJ.BL.dealInitialRotation(rotation,event,dealX(x,event,false),dealY(y,event,false));
    roSpeed=30/roSpeed/Math.PI;
    extraRo=extraRo||0;
    //====================================
    let bullet = {
        initialRotation:ro*180/Math.PI,
        Max:120,
        RotationAuto:0,
        Img:"dart",
        Regions:[1],
        x:x,
        y:y,
        MoveType:"S[]"
    }
    for (let i in data) bullet[i] = data[i];
    for (let i=0;i<number;i++) {
        bullet.MoveType=makeText(r,roSpeed,i,number,speed);
        QJ.BL.Shoot(JsonEx.makeDeepCopy(bullet));
    }
    //====================================
}
QJ.BL.Shooter_ArcRange = function(initialRotation,data,arc) {
    //====================================
    for (let i=arc[0],delta = (arc[1] - arc[0]) / arc[2];i<arc[1];i+=delta) {
        data["initialRotation"] = initialRotation+"+"+(i+(Math.random()-0.5)*arc[3]);
        QJ.BL.Shoot(JsonEx.makeDeepCopy(data));
    }
    //====================================
}
QJ.BL.Shooter_HandGrenade = function(data,oneLength,oneTime,maxReBound) {
    //====================================
    //一倍宽度,发射角度,一倍时间,次数
    let bullet = {
        MoveType:"QP["+oneLength+","+Math.PI/3+","+oneTime+","+maxReBound+"]",
        Max:oneTime*(maxReBound+1)*maxReBound/2,
        NoCollisionAction:true,
        NoCollisionAnim:true,
        DeadAction:true,
        DeadAnim:true,
        Speed:18,
        ReBound:999999,
        AnchorY:0.5,
        AtkRange:96,
        CollisionBox:"C[16]",
        WaitBaseOnSpeed:-1
    };
    for (let i in data) bullet[i] = data[i];
    QJ.BL.Shoot(bullet);
    //====================================
}
QJ.BL.Shadow = function(character,data) {
    //====================================
    let tar = character==-1?($gamePlayer.vehicle()?$gamePlayer.vehicle():$gamePlayer):
        (character==0?QJ.BL.getEvent():$gameMap.event(character));
    if (!tar) return;
    //====================================
    let bullet = {
        initialRotation:0,
        x:tar.screenX(),
        y:tar.screenY(),
        Speed:0,
        Img:[0,character],
        Bit:true,
        AnchorX:0.5,
        AnchorY:1
    };
    for (let i in data) bullet[i] = data[i];
    QJ.BL.Shoot(bullet);
    //====================================
}
QJ.BL.addShadow = function(character,data,time,delta) {
    //====================================
    let tar;
    if (character==-1) {
        tar = $gamePlayer;
    } else {
        if (character==0) tar = QJ.BL.getEvent();
        else tar = $gameMap.event(character);
    }
    //====================================
    tar.addShadowCircle(character==0?tar._eventId:character,data,QJ.BL.dealTime(time),delta);
    //====================================
}
Bitmap.prototype.getWAndH = function(text,fontsize) {
    var context = this._context;
    context.save();
    this.fontSize = fontsize;
    context.font = this._makeFontNameText();
    var data = context.measureText(text);
    context.restore();
    return data;
};
QJ.BL.Text = function(text,color,fontsize,linecolor,linewidth,character,data) {
    //====================================
    let tar = character==-1?$gamePlayer:
        (character==0?QJ.BL.getEvent():$gameMap.event(character));
    if (!tar) return;
    let d=tar.direction();
    let bitmapData = new Bitmap(1,1);
    let WAndH = bitmapData.getWAndH(text,fontsize),box;
    if (d==2||d==8) {
        box="R["+fontsize+","+(d==2||d==8?fontsize*text.length:WAndH.width)+"]";
    } else {
        box="R["+(d==2||d==8?fontsize*text.length:WAndH.width)+","+fontsize+"]";
    }
    //====================================
    let bullet = {
        Pierce:100,
        Speed:2,
        x:tar.boxScreenSubX()+(d==4?-text.length*fontsize/2:(d==6?text.length*fontsize/2:0)),
        y:tar.boxScreenSubY()+(d==8?-text.length*fontsize/2:(d==2?text.length*fontsize/2:0)),
        Img:[1,text,color,fontsize,(d==2||d==8?1:0),fontsize*text.length,fontsize,linecolor,linewidth],
        CollisionBox:box,
        AnchorX:0.5,
        AnchorY:0.5,
        PierceAction:true,
        RotationAuto:0,
        initialRotation:(d==2?180:(d==4?270:(d==6?90:0))),
    };
    for (let i in data) bullet[i] = data[i];
    QJ.BL.Shoot(bullet);
    //====================================
}
QJ.BL.Pic = function(data) {
    //====================================
    let bullet = {
        Max:-1,
        initialRotation:0,
        AnchorX:0,
        AnchorY:0,
        x:0,
        y:0,
        Bit:true,
        Speed:0
    };
    for (let i in data) bullet[i] = data[i];
    QJ.BL.Shoot(bullet);
    //====================================
}
QJ.BL.Shoot = function(data,bo) {//=====================Shoot================
    //======================================
    let bullet = {
        //======================================
        initialRotation:"PD[]",
        x:"P[]",
        y:"P[]",
        z:"C[]",
        scaleX:100,
        scaleY:100,
        //======================================
        MoveType:"S[]",
        Regions:[],
        Terrains:[],
        Target:[],
        Pierce:0,
        //======================================
        Img:"bullet0",
        Anim:0,
        DeadCount:0,
        DeadScale:100,
        Speed:12,
        Max:120,
        RotationAuto:-1,
        //======================================
        Action:[],
        CollisionBox:"R[4,4]",
        //======================================
        Tone:[0,0,0,0],
        Blend:[0,0,0,0],
        Hex:0,
        Opacity:255,
        AfterImage:[],
        Light:[],
        Particles:[],
        AtkRange:0,
        DeadAction:false,
        PierceAction:false,
        NoCollisionAction:false,
        DeadAnim:true,
        PierceAnim:false,
        NoCollisionAnim:false,
        ReBound:false,
        AnchorX:0.5,
        AnchorY:0.5,
        rTRotation:"",
        bTRotation:"",
        WaitBaseOnSpeed:-2,
        LMD:true,
        Bit:false,
        //======================================
        UpdateJS:"",
        MoveJS:[],
        DeadJS:"",
        UpdateQT:"",
        MoveQT:[],
        DeadQT:"",
        Name:"",
        noPassDo:false,
        blendMode:0,
        clearProjectile:"",
        cancalEachOther:true,
        onScreen:false,
        //======================================
    };
    //======================================
    if (!bo) {
        for (let i in data) bullet[i] = data[i];
    } else bullet=data;
    //======================================
    let event=QJ.BL.getEvent();
    //======================================
    bullet["MoveType"] = QJ.BL.dealMoveType(bullet["MoveType"],event);
    if (bullet["MoveType"][0]==9) {
        bullet["xRem"] = QJ.BL.dealData0InXY(JsonEx.makeDeepCopy(bullet["x"]));
        bullet["yRem"] = QJ.BL.dealData0InXY(JsonEx.makeDeepCopy(bullet["y"]));
        bullet["initialRotationRem"] = QJ.BL.dealData0InXY(JsonEx.makeDeepCopy(bullet["initialRotation"]));
    }
    //======================================
    GroupRandomList = []
    GroupRandomReLoad = false;
    bullet["x"] = dealX(bullet["x"],event);
    GroupRandomReLoad = true;
    bullet["y"] = dealY(bullet["y"],event);
    bullet["initialRotation"] = 
        QJ.BL.dealInitialRotation(bullet["initialRotation"],event,bullet["x"],bullet["y"]);
    //======================================
    bullet["z"] = QJ.BL.dealZ(bullet["z"],event);
    bullet["CollisionBox"] = bullet["CollisionBox"]=='auto'?['C',1,'auto']:QJ.BL.dealCollisionBox(bullet["CollisionBox"]);
    if (typeof bullet["Img"] == "object"&&bullet["Img"][0]==0&&bullet["Img"][1]==0) 
        bullet["Img"][1] = QJ.BL.getEvent()._eventId;
    //======================================
    //console.log(bullet);
    bullet.scaleX = new QJFrame("scaleX",bullet.scaleX,0);
    bullet.scaleY = new QJFrame("scaleY",bullet.scaleY,0);
    bullet.Speed = new QJFrame("Speed",bullet.Speed,0);
    bullet.Opacity = new QJFrame("Opacity",bullet.Opacity,0);
    bullet.ReBound = (typeof bullet.ReBound == "boolean"?(bullet.ReBound?999999:0):bullet.ReBound);
    bullet.Max = QJ.BL.dealMax(bullet.Max,event);
    //======================================
    if (QJ.BL.findNull(bullet)) return null;
    return $gameMap.addBullet(bullet,0);
    //======================================
}
QJ.BL.deleteBullet = function(name) {
    let tempData = $gameMap._mapBullets,bullet;
    for (let i in tempData) {
        bullet = tempData[i];
        if (!bullet) {
            continue;
        }
        if (bullet.bulletMode!=0||!bullet.data.Name) {
            continue;
        }
        if (bullet.data.Name.indexOf(name)>-1) {
            bullet.setDirectDead();
        }
    }
}
QJ.BL.setBulletDisappear = function(name) {
    let tempData = $gameMap._mapBullets,bullet;
    for (let i in tempData) {
        bullet = tempData[i];
        if (!bullet) {
            continue;
        }
        if (bullet.bulletMode!=0||!bullet.data.Name) {
            continue;
        }
        if (bullet.data.Name.indexOf(name)>-1) {
            bullet.setDeadDisappear();
        }
    }
}
QJ.BL.Quick = function(id,data) {
    if (!Preset[String(id)]) {
        console.log("id为"+id+"的预设不存在。");
        return;
    }
    let bullet = JsonEx.makeDeepCopy(Preset[String(id)]);
    for (let i in data) bullet[i] = data[i];
    QJ.BL.Shoot(bullet,true);
}
//=======================================LASER=======================================LASER
QJ.BL.Laser = function(data) {//=====================Laser================
    //======================================
    let bullet={
        name:"",
        initialRotation:"M[]",
        RotationAuto:-1,
        x:"P[]",
        y:"P[]",
        z:"C[]",
        Action:[],
        Regions:[],
        Terrains:[],
        Target:[],
        Img:"laser1",
        ImgPoint:"laser1Point",
        DeadCount:0,
        Tone:[0,0,0,0],
        Blend:[0,0,0,0],
        Hex:0,
        Opacity:255,
        Width:12,
        AtkWait:30,
        ReBound:10,
        Max:120,
        ScaleX:100,
        MaxLength:960,
        noPassDo:false,
        UpdateJS:"",
        blendMode:0,
        clearProjectile:"",
        lineExpandMode:false,
        lineExpandScrollSpeed:0,
    }
    //======================================
    for (let i in data) bullet[i] = data[i];
    //======================================
    let event=QJ.BL.getEvent();
    bullet.z = QJ.BL.dealZ(bullet.z,QJ.BL.getEvent(),false);
    if (event) {
        if (typeof bullet.x == "string") bullet.x=bullet.x.replace(/E\[0\]/ig,"E["+event._eventId+"]");
        if (typeof bullet.y == "string") bullet.y=bullet.y.replace(/E\[0\]/ig,"E["+event._eventId+"]");
        if (typeof bullet.initialRotation == "string") 
            bullet.initialRotation=bullet.initialRotation.replace(/D\[0\]/ig,"D["+event._eventId+"]");
    }
    //======================================
    bullet.Opacity= new QJFrame("Opacity",bullet.Opacity,0);
    bullet.ScaleX = new QJFrame("scaleX",bullet.ScaleX,0);
    bullet.Width = new QJFrame("Width",bullet.Width,0);
    bullet.Max = QJ.BL.dealMax(bullet.Max,event);
    bullet.MaxLength = new QJFrame("MaxLength",bullet.MaxLength,0);
    //======================================
    if (QJ.BL.findNull(bullet)) return null;
    return $gameMap.addBullet(bullet,1);
    //======================================
}
QJ.BL.deleteLaser = function(name) {
    let tempData = $gameMap._mapBullets,bullet;
    for (let i in tempData) {
        bullet = tempData[i];
        if (!bullet) {
            continue;
        }
        if (bullet.bulletMode!=1) {
            continue;
        }
        if (bullet.data.Name.indexOf(name)>-1) {
            i.setDead();
        }
    }
}
QJ.BL.deleteTwoPoint = function(name) {
    let tempData = $gameMap._mapBullets,bullet;
    for (let i in tempData) {
        bullet = tempData[i];
        if (!bullet) {
            continue;
        }
        if (bullet.bulletMode!=2) {
            continue;
        }
        if (bullet.data.Name.indexOf(name)>-1) {
            i.setDead();
        }
    }
}
QJ.BL.dealCharacter = function(data) {
    if (typeof data == "object") {
        return data;
    } else {
        if (typeof data != "number") data = Number(data);
        if (data==-1) return $gamePlayer;
        else if (data==0) return QJ.BL.getEvent()?QJ.BL.getEvent():null;
        else if (data>0) return $gameMap.event(data)?$gameMap.event(data):null;
        else return null;
    }
}
//==============================================================================
QJ.BL.TwoPoint = function(x1,y1,x2,y2,data) {//=====================TwoPoint================
    //======================================
    let bullet={
        Img:"electricity[4,5]",
        Max:240,
        DeadCount:5,
        x1:x1,
        y1:y1,
        x2:x2,
        y2:y2,
        z:3,
        Opacity:255,
        Tone:[0,0,0,0],
        Blend:[0,0,0,0],
        Hex:0,
        ScaleX:100,
        Action:[],
        Target:[],
        Width:24,
        AtkWait:30,
        ExtraRotation:0,
        AtkRange:0,
        blendMode:0,
        clearProjectile:"",
        lineMode:"L[]",
        ImgPoint:""
    }
    //======================================
    for (let i in data) bullet[i] = data[i];
    //======================================
    let event=QJ.BL.getEvent();
    bullet.z = QJ.BL.dealZ(bullet.z,QJ.BL.getEvent(),false);
    if (event) {
        if (typeof bullet.x1 == "string") bullet.x1=bullet.x1.replace(/E\[0\]/ig,"E["+event._eventId+"]");
        if (typeof bullet.y1 == "string") bullet.y1=bullet.y1.replace(/E\[0\]/ig,"E["+event._eventId+"]");
        if (typeof bullet.x2 == "string") bullet.x2=bullet.x2.replace(/E\[0\]/ig,"E["+event._eventId+"]");
        if (typeof bullet.y2 == "string") bullet.y2=bullet.y2.replace(/E\[0\]/ig,"E["+event._eventId+"]");
    }
    //======================================
    bullet.Opacity= new QJFrame("Opacity",bullet.Opacity,0);
    bullet.ScaleX = new QJFrame("scaleX",bullet.ScaleX,0);
    bullet.Width = new QJFrame("Width",bullet.Width,0);
    bullet.Max = QJ.BL.dealMax(bullet.Max,event);
    //======================================
    if (QJ.BL.findNull(bullet)) return null;
    return $gameMap.addBullet(bullet,2);
    //======================================
}
//==============================================================================
QJ.BL.quickOrder = function(id) {
    if (!PresetText[String(id)]) {
        console.log("id为"+id+"的预设不存在。");
        return;
    }
    PresetText[id].call(this);
}
//=============================================================================
//ImageManager.
//=============================================================================
ImageManager.loadBullet = function(filename,hue = 0) {
    return this.loadBitmap('img/bullets/', filename, hue, false);
};
ImageManager.reserveBullet = function(filename,hue = 0) {
    return this.reserveBitmap('img/bullets/', filename, 0, false, null);
};
//=============================================================================
//Event.
//=============================================================================
const QJBL_Game_Event_initMembers = Game_Event.prototype.initMembers;
Game_Event.prototype.initMembers = function() {
    QJBL_Game_Event_initMembers.call(this);
    this._annotationData = "";
    this._groupData = [];
};
const QJBL_Game_Event_setupPage = Game_Event.prototype.setupPage;
Game_Event.prototype.setupPage = function() {
    QJBL_Game_Event_setupPage.call(this);
    this.refreshBodyBox();
    this._annotationData = QJ.BL.calculateAnnotation(this);
    this._groupData = QJ.BL.calculateGroup(this._annotationData);
    if (this._groupData!="") {
        this._groupData = this._groupData.split(',');
        for (let i=0,il=this._groupData.length;i<il;i++) {
            if (this._groupData[i][0]=='"'&&
                this._groupData[i][this._groupData[i].length-1]=='"') {
                this._groupData[i] = eval(this._groupData[i]);
            } else if (this._groupData[i][0]=='\''&&
                this._groupData[i][this._groupData[i].length-1]=='\'') {
                this._groupData[i] = eval(this._groupData[i]);
            }
        }
        for (let i of this._groupData) {
            $gameMap._groupList[i] = null;
        }
    }
};
//=============================================================================
//Map.
//=============================================================================
Game_Map.prototype.maxScreenWidth = function() {
    return this._maxScreenWidth;
};
Game_Map.prototype.maxScreenHeight = function() {
    return this._maxScreenHeight;
};
Game_Map.prototype.noPassBox = function(x,y) {
    x = Math.floor(x+0.5);
    y = Math.floor(y+0.5);
    if (x<0||x>=$gameMap.width()||y<0||y>=$gameMap.height()) return true;
    return this._noPassBox[x][y];
};
Game_Map.prototype.noPassBoxLaser = function(x,y) {
    x = Math.round(x);
    y = Math.round(y);
    if (x<0||x>=$gameMap.width()||y<0||y>=$gameMap.height()) return true;
    return this._noPassBox[x][y]&&this._noPassBoxLaser[x][y]!=this._noPassLaserIndexNow;
};
Game_Map.prototype.judgeColliedWithRegion = function(body,id) {
    return false;
};
Game_Map.prototype.judgeColliedWithTerrain = function(body,id) {
    return false;
};
Game_Map.prototype.refreshMapBox = function() {
    //console.time("allTime");
    //========================================
    this._maxScreenWidth=this.width()*tileSize;
    this._maxScreenHeight=this.height()*tileSize;
    //========================================
    this._noPassBox=[];
    this._noPassBoxLaser=[];
    let nP = this._noPassBox,nPX = this._noPassBoxLaser;
    let g2,g4,g6,g8;
    for (let x=0,xl=$dataMap.width;x<xl;x++) {
        nP[x] = [];
        nPX[x] = [];
        for (let y=0,yl=$dataMap.height;y<yl;y++) {
            g2=this.isPassable(x,y,2);
            g4=this.isPassable(x,y,4);
            g6=this.isPassable(x,y,6);
            g8=this.isPassable(x,y,8);
            nP[x].push(g2&&g4&&g6&&g8);
            nPX[x].push(0);
        }
    }
    this._noPassLaserIndexNow = 1; 
    //========================================
    //console.timeEnd("allTime");
    //========================================
};
const QB_Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function(mapId) {
    this.initMapBullets();
    this._forceInterpreterQB = new Array();
    this._groupList = {};
    QB_Game_Map_setup.call(this,mapId);
    this.refreshMapBox();
    this.refreshUpdateBoxData();
};
Game_Map.prototype.initMapBullets = function() {
    this._mapBullets = {};
    this._mapBulletsQJLength = 0;
    this._mapBulletsName = {};
};
Game_Map.prototype.recreateBullets = function(scene) {
    if (!this._mapBullets || !this._mapBulletsQJLength) {
        return;
    }
    let bullets = this._mapBullets;
    for (let i in bullets) {
        if (bullets[i]) {
            scene.createBullet(bullets[i]);
        }
    }
};
Game_Map.prototype.addMapBulletsName = function(index,name) {
    if (!name) return;
    for (let i=0,il=name.length;i<il;i++) {
        if (!this._mapBulletsName[name[i]]) {
            this._mapBulletsName[name[i]] = [];
        }
        this._mapBulletsName[name[i]].push(index);
    }
};
Game_Map.prototype.deleteMapBulletsName = function(index,name) {
    if (!name) return;
    for (let i=0,il=name.length;i<il;i++) {
        if (!this._mapBulletsName[name[i]]) {
            this._mapBulletsName[name[i]] = [];
            continue;
        }
        for (let jdata=this._mapBulletsName[name[i]],j=jdata.length-1;j>=0;j--) {
            if (jdata[j]==index) {
                jdata.splice(j,1);
            }
        }
    }
};
Game_Map.prototype.refreshUpdateBoxData = function() {
    //====================================
    let newNumber = ++this._noPassLaserIndexNow;
    for (let i of $gameMap.events()) {
        if (i.laserObstacle) this._noPassBoxLaser[Math.floor(i.x+0.5)][Math.floor(i.y+0.5)] = newNumber;
    }
    //====================================
    this._groupList = {};
    for (let i=0,idata=$gameMap.events(),il=idata.length,event;i<il;i++) {
        event = idata[i];
        if (event&&event._groupData.length>0) {
            for (let j of event._groupData) {
                if (!this._groupList[j]) {
                    this._groupList[j] = [];
                }
                this._groupList[j].push(event._eventId);
            }
        }
    }
    //====================================
};
/*const QJB_Game_Map_update = Game_Map.prototype.update;
Game_Map.prototype.update = function(sceneActive) {
    QJB_Game_Map_update.call(this,sceneActive);

};*/
Game_Map.prototype.updateBulletsQJ = function() {
    //====================================
    this.refreshUpdateBoxData();
    //====================================
    for (let i=0,l=this._forceInterpreterQB.length;i<l;i++) {
        if (!this._forceInterpreterQB[i]) continue;
        if (!this._forceInterpreterQB[i].isRunning()) {
            this._forceInterpreterQB[i].setup(
                $dataCommonEvents[this._forceInterpreterQB[i].commonEventId].list,
                this._forceInterpreterQB[i].EID>0?this._forceInterpreterQB[i].EID:0);
        }
        this._forceInterpreterQB[i].update();
    }
    //====================================
    this._aliveBullet=0;
    //console.time("allTime");
    let bullets = this._mapBullets;
    for (let i in bullets) {
        if (bullets[i]) {
            this._aliveBullet++;
            bullets[i].update();
        }
    }
    //console.timeEnd("allTime");
    //====================================
};
const QJB_Scene_Map_updateMain = Scene_Map.prototype.updateMain;
Scene_Map.prototype.updateMain = function() {
    QJB_Scene_Map_updateMain.apply(this,arguments);
    if (this.isActive()) {
        $gameMap.updateBulletsQJ();
    }
};
Game_Map.prototype.bulletsNumber = function() {
    return $gameMap._aliveBullet;
};
Game_Map.prototype.addBullet = function(bullet,type) {
    if (showWarn) {
        if ($gameMap._aliveBullet>=maxbullet) {
            console.warn("The number of bullets has reached the limit."+
                "And the number is"+$gameMap._aliveBullet+".");
            return null;
        }
    }
    let bulletsTarget;
    let newIndex = this._mapBulletsQJLength++;
    if (!type) bulletsTarget=new Game_QJBullet(bullet,newIndex);
    else if (type==1) bulletsTarget=new Game_QJLaser(bullet,newIndex);
    else if (type==2) bulletsTarget=new Game_QJTwoPoint(bullet,newIndex);
    if (bulletsTarget && !bulletsTarget.dead) {
        this._mapBullets[newIndex] = bulletsTarget;
        SceneManager._scene._spriteset.createBullet(newIndex);
    }
    return bulletsTarget;
};
Game_Map.prototype.removeBullet = function(index) {
    let data;
    if (typeof index === "object") {
        data = index;
    } else {
        data = this._mapBullets[index];
    }
    if (data) {
        data.destroy();
        if (data.bulletMode==0) {
            this.deleteMapBulletsName(data.index,data.name);
        }
        data = null;
        this._mapBullets[index] = null;
        delete this._mapBullets[index];
    }
};
Game_Map.prototype.bullet = function(index) {
    return this._mapBullets[index];
};
Game_Map.prototype.findBulletSprite = function(data) {
    if (!SceneManager._scene._spriteset) return null;
    let contain,target = null;
    if (data.data.z=="T") {
        contain = SceneManager._scene._spriteset._parallaxBulletContainer;
    } else if (data.data.z=="M") {
        contain = SceneManager._scene._spriteset._mapBulletContainer;
    } else if (data.data.z=="P") {
        contain = SceneManager._scene._spriteset._upperBulletContainer;
    } else {
        contain = SceneManager._scene._spriteset._lowerBulletContainer;
    }
    for (let i of contain.children) {
        if (i.o==data) {
            target = i;
            break;
        }
    }
    return target;
};
//=============================================================================
//Extra plugin order.
//=============================================================================
QJ.BL.callCE = function (id,bullet) {
    QJ.BL.callCommonEvent(id,0,[],{x:bullet.screenShowX(),y:bullet.screenShowY()});
}
QJ.BL.SetMove = function(bo) {
    forBidDestination = !(!!bo);
}
QJ.BL.ClearAll = function() {
    if (!SceneManager._scene) return;
    if (!SceneManager._scene._spriteset) return;
    SceneManager._scene._spriteset.clearAllButtle();
    $gameMap.initMapBullets();
}
//=============================================================================
//Boot.
//=============================================================================
const QJB_Scene_Boot_loadSystemImages = Scene_Boot.loadSystemImages;
Scene_Boot.loadSystemImages = function() {
    QJB_Scene_Boot_loadSystemImages.call(this);
    for (let i of reserveImg) {
        if (i.includes("|")) {
            let detail = i.split("|");
            for (let j of detail) {
                ImageManager.reserveBullet(j);
            }
        } else ImageManager.reserveBullet(i);
    }
};
//=============================================================================
//Bitmap
//=============================================================================
Bitmap.prototype.drawTextChangeRotation = function(text, x, y, maxWidth, lineHeight, align ,rotation) {
    if (text !== undefined) {
        var tx = x;
        var ty = y + lineHeight - (lineHeight - this.fontSize * 0.7) / 2;
        var context = this._context;
        var alpha = context.globalAlpha;
        maxWidth = maxWidth || 0xffffffff;
        if (align === 'center') {
            tx += maxWidth / 2;
        }
        if (align === 'right') {
            tx += maxWidth;
        }
        context.save();
        context.translate(0,0);
        context.rotate(rotation);
        context.translate(0,-lineHeight+4);
        context.font = this._makeFontNameText();
        context.textAlign = align;
        context.textBaseline = 'alphabetic';
        context.globalAlpha = 1;
        this._drawTextOutline(text, tx, ty, maxWidth);
        context.globalAlpha = alpha;
        this._drawTextBody(text, tx, ty, maxWidth);
        context.restore();
        this._setDirty();
    }
};
Bitmap.prototype.drawTextVerticalRow = function(text, x, y, maxWidth, lineHeight, align) {
    if (text !== undefined) {
        var tx = x + lineHeight / 2;
        var ty = y + lineHeight - (lineHeight - this.fontSize * 0.7) / 2;
        var context = this._context;
        var alpha = context.globalAlpha;
        maxWidth = maxWidth || 0xffffffff;
        context.save();
        context.font = this._makeFontNameText();
        context.textAlign = align;
        context.textBaseline = 'alphabetic';
        for (let i=0;i<text.length;i++) {
            context.globalAlpha = 1;
            this._drawTextOutline(text[i], tx, ty+i*lineHeight, maxWidth);
            context.globalAlpha = alpha;
            this._drawTextBody(text[i], tx, ty+i*lineHeight, maxWidth);
        }
        context.restore();
        this._setDirty();
    }
};
//=============================================================================
//Base Tool.
//=============================================================================
QJ.BL.pseudoRandom = function(seed) {
    return (seed* 9301 + 49297) % 233280; 
};
QJ.BL.randomColor = function(start,length) {
    return QJ.BL.rgbToHex({
        r:start+Math.floor(Math.random()*length),
        g:start+Math.floor(Math.random()*length),
        b:start+Math.floor(Math.random()*length)});
}
QJ.BL.ColorGrad = function(bitmap,content,x,y,w,h,ro) {
    if (!content.includes("|")) return content;
    const list=content.split("~");
    const colorNum = list.length;
    let k = Math.atan(w/h),diaL = Math.sqrt(w*w+h*h)/2,noSoildRadius;
    ro = ro%(Math.PI*2);
    if (ro<Math.PI/2) noSoildRadius = diaL*Math.cos(k-ro);
    else if (ro<Math.PI) noSoildRadius = -diaL*Math.cos(k+ro);
    else if (ro<Math.PI*3/2) noSoildRadius = -diaL*Math.cos(k-ro);
    else noSoildRadius = diaL*Math.cos(k+ro);
    const grad = bitmap._context.createLinearGradient(
        Math.floor(x+w/2+noSoildRadius*Math.sin(ro)),Math.floor(y+h/2-noSoildRadius*Math.cos(ro)),
        Math.floor(x+w/2-noSoildRadius*Math.sin(ro)),Math.floor(y+h/2+noSoildRadius*Math.cos(ro)));
    for(let i=0; i<colorNum; i++) {
        let detail = list[i].split("|");
        grad.addColorStop(detail[0],detail[1]);
    }
    return grad;
}
QJ.BL.hexToRgb = function (hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return {r: parseInt(result[1],16),g: parseInt(result[2], 16),b: parseInt(result[3], 16)};
}
QJ.BL.rgbToHex = function (rgb) {
    let r=rgb.r.toString(16),g=rgb.g.toString(16),b=rgb.b.toString(16);
    return "#"+(r.length==1?("0"+r):r)+(g.length==1?("0"+g):g)+(b.length==1?("0"+b):b);
}
let calculateAngleByTwoPoint = QJ.BL.calculateAngleByTwoPoint =function(x,y,ex,ey){
    let ro;
    if (ex>x&&ey<y)  ro=(-Math.atan((x-ex)/(y-ey)));
    if (ex>x&&ey>y)  ro=(Math.PI-Math.atan((x-ex)/(y-ey)));
    if (ex<x&&ey>y)  ro=(Math.PI-Math.atan((x-ex)/(y-ey)));
    if (ex<x&&ey<y)  ro=(2*Math.PI-Math.atan((x-ex)/(y-ey)));
    if (ex==x&&ey>y) ro=Math.PI;
    if (ex==x&&ey<y) ro=0;
    if (ex>x&&ey==y) ro=Math.PI/2;
    if (ex<x&&ey==y) ro=Math.PI*3/2;
    if (ex==x&&ey==y)ro=null;//说明在同一点
    return ro;
};
QJ.BL.calculateAngleByDirection=function(direction){
    if (direction==1) return Math.PI*5/4;//左下
    if (direction==2) return Math.PI;
    if (direction==3) return Math.PI*3/4;//右下
    if (direction==4) return Math.PI*3/2;
    if (direction==6) return Math.PI/2;
    if (direction==7) return Math.PI*7/4;//左上
    if (direction==8) return 0;
    if (direction==9) return Math.PI/4;//右上
    return 0;
};
QJ.BL.calculateAnnotation = function(event) {
    let page=null,content="";
    try{
        page=event.page();
    } catch(e) {
        page=null;
    }
    if (page) {
        if (page.list[0].code === 108) {
            let i=0;
            while (page.list[i].code === 408 || page.list[i].code === 108) {
                content=content + page.list[i].parameters[0];
                i++;
            }
        }
    }
    return content;
};
QJ.BL.calculateGroup = function(content) {
    let detail = content.match(/<Group:[^>]*>/i);
    return detail?(detail[0].substr(7,detail[0].length-8)):"";
};
QJ.BL.getGroup = function(name) {
    return $gameMap.events().filter((event)=>{
        return event&&event._groupData.includes(name);
    });
};
QJ.BL.getGroupId = function(name) {
    return $gameMap._groupList[name];
};
QJ.BL.getGroupIdInRange = function(name,ox,oy,range) {
    let eventData,ax,ay;
    range=range*range;
    ox+=$gameMap.displayX()*48;
    oy+=$gameMap.displayY()*48;
    return $gameMap._groupList[name].filter((event)=>{
        if (!event) return false;
        eventData = $gameMap.event(event);
        if (!eventData) return false;
        ax = eventData.boxScreenX() - ox;
        ay = eventData.boxScreenY() - oy;
        return ax*ax+ay*ay<=range;
    });
};
QJ.BL.getGroupIdMap = function(name) {
    let list = [];
    for (let i=0,idata=$gameMap.events(),il=idata.length,event;i<il;i++) {
        event = idata[i];
        if (event) {
            if (event._groupData.includes(name)) {
                list.push(event._eventId);
            }
        }
    }
    return list;
};
QJ.BL.getMinEventId = function(x,y,group,num,range) {
    let basedata=null,min=9999999,id=0;
    num=(!num)?1:num;
    range=range||null;
    if (group) {
        basedata=QJ.BL.getGroup(group);
    } else {
        basedata=$gameMap.events();
    }
    let ax,ay,bx,by,dis;
    if (range&&range>0) {
        range=range*range;
        basedata = basedata.filter((event)=>{
            ax = event.boxScreenX()-x;
            ay = event.boxScreenY()-y;
            return ax*ax+ay*ay<=range;
        });
    }
    basedata = basedata.sort((a,b)=>{
        ax = a.boxScreenX();
        ay = a.boxScreenY();
        bx = b.boxScreenX();
        by = b.boxScreenY();
        dis = ((ax-x)*(ax-x)+(ay-y)*(ay-y))-((bx-x)*(bx-x)+(by-y)*(by-y));
        return dis>0?1:(dis<0?-1:0);
    });
    if (num==-1) {
        return basedata;
    } else {
        id = basedata[Math.min(num,basedata.length)-1];
        return id?id._eventId:0;
    }
};
QJ.BL.getCommentId = function(name) {
    let basedata=$gameMap.events(),eventIdList=new Array();
    for (let i of basedata) {
        if (i&&i.event()&&i.event().note.includes(name)) {
            if (i._pageIndex>=0) {
                eventIdList.push(i._eventId);
            }
        }
    }
    return eventIdList;
};
QJ.BL.getComment = function(name) {
    let basedata=$gameMap.events(),eventIdList=new Array();
    for (let i of basedata) {
        if (i&&i.event()&&i.event().note.includes(name)) {
            if (i._pageIndex>=0) {
                eventIdList.push(i);
            }
        }
    }
    return eventIdList;
};
QJ.BL.getMinEventIdNobi = function(x,y,nobi) {
    let basedata=null,min=9999999,id=0;
    if (nobi) {
        basedata=QJ.BL.getComment(nobi);
    } else {
        basedata=$gameMap.events();
    }
    for (let i of basedata) {
        let length=(i.boxScreenX()-x)*(i.boxScreenX()-x)+(i.boxScreenY()-y)*(i.boxScreenY()-y);
        if (length<min) {
            id=i._eventId;
            min=length;
        }
    }
    return id;
};
QJ.BL.error=function(content){
    if (!showWarn) return;
    throw new Error("子弹数据中的"+content+"书写错误。");
};
QJ.BL.findNull=function(bullet){
    for (var i in bullet) {
        if (bullet[i]==null) {
            if (!showWarn) return true;
            console.error("参数录入有误，某子弹未成功创建。错误点："+i);
            return true;
        } 
    }
    return false;
};
QJ.BL.getAnnotation = function(event) {
    let page=null,content="";
    try{page=event.page();} catch(e) {page=null;}
    if (page) {
        if (page.list[0].code === 108) {
            let i=0;
            while (page.list[i].code === 408 || page.list[i].code === 108) {
                content=content + page.list[i].parameters[0];
                i++;
            }
        }
    }
    return content;
};
QJ.BL.dealCollisionBox = function(data) {
    let tarList=new Array();
    if (data[0]=="C") {
        let detail=eval(data.match(/\[[^\]]*\]/i)[0]);
        if (!detail||isNaN(Number(detail[0]))) return null;
        return [0,Number(detail[0])];
    } else if (data[0]=="R") {
        let detail=eval(data.match(/\[[^\]]*\]/i)[0]);
        if (!detail||isNaN(Number(detail[0]))||isNaN(Number(detail[1]))) return null;
        return [1,Number(detail[0]),Number(detail[1])];
    }
    return null;
};
//=============================================================================
//System.
//=============================================================================
QJ.BL.createBaseTexture = function(bit) {
    let lsCanvas = document.createElement('canvas');
    let lscontext = lsCanvas.getContext('2d');
    let lsBaseTexture = null;
    let w=bit.width,h=bit.height;
    lsCanvas.width = w;
    lsCanvas.height = h;
    lsBaseTexture = new PIXI.BaseTexture(lsCanvas);
    lsBaseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
    lsBaseTexture.width = w;
    lsBaseTexture.height = h;
    lscontext.globalCompositeOperation = 'source-over';
    lscontext.drawImage(bit._canvas,0,0,w,h,0,0,w,h);
    lsBaseTexture.update();
    return lsBaseTexture;
};
//=============================================================================
//System.
//=============================================================================
const QJB_Game_Temp_setDestination = Game_Temp.prototype.setDestination
Game_Temp.prototype.setDestination = function(x, y) {
    if (forBidDestination) return;
    QJB_Game_Temp_setDestination.call(this,x,y);
};
const QJB_Game_Interpreter_executeCommand = Game_Interpreter.prototype.executeCommand;
Game_Interpreter.prototype.executeCommand = function() {
    QJBInter=this;
    return QJB_Game_Interpreter_executeCommand.call(this);
};
QJ.BL.getEvent = ()=>{
    return (typeof QJBInter == "number")?$gameMap.event(QJBInter):$gameMap.event(QJBInter._eventId);
};
//=============================================================================
//QJFrame./ fade effect.| direction effect.
//=============================================================================
QJFrame.prototype.initialize = function(name,orginData,dataType,noFadeCopy) {
    noFadeCopy = noFadeCopy||false;
    this.i = dataType;//0-number 1-text 2-degree
    this.n = name;
    this.d = {};
    this.m = 0;
    this.t = 0;
    this.rt = 0;
    this.isMode = true;
    if (typeof orginData == "string"&&orginData.includes("~")) {
        let data = orginData.split("~"),num=0,fadeT=0,last;
        for (let i=0,il=data.length,detail;i<il;i++) {
            if (data[i].includes("|")) {
                detail = data[i].split("|");
                if (dataType==0) num = Number(detail[1]);
                else if (dataType==1) num = detail[1];
                else if (dataType==2) num = Number(detail[1])*Math.PI/180;
                this.d[this.m] = num;
                if (noFadeCopy) {
                    for (let i=this.m,ll=Number(detail[0]);i<ll;i++) {
                        this.d[i] = num;
                    }
                }
                this.m+=Number(detail[0]);
                this.d[this.m] = num;
            } else if (data[i].includes("/")) {
                detail = data[i].split("/");
                fadeT = Number(detail[0]);
                if (dataType==0) {
                    num = Number(detail[1]);
                    last = this.d[this.m];
                    for (let j=1;j<=fadeT;j++) {
                        this.d[this.m+j] = last+(num-last)*j/fadeT;
                    }
                    this.m+=fadeT;
                    this.d[this.m] = num;
                } else if (dataType==1) {
                    num = QJ.BL.hexToRgb(detail[1]);
                    last = QJ.BL.hexToRgb(this.d[this.m])//[0,{r:0,g:0,b:0}];
                    for (let j=1;j<=fadeT;j++) {
                        this.d[this.m+j] = QJ.BL.rgbToHex({
                            r:Math.floor(last.r+(num.r-last.r)*j/fadeT),
                            g:Math.floor(last.g+(num.g-last.g)*j/fadeT),
                            b:Math.floor(last.b+(num.b-last.b)*j/fadeT)
                        });
                    }
                    this.m+=fadeT;
                    this.d[this.m] = detail[1];
                } else if (dataType==2) {
                    num = Number(detail[1])*Math.PI/180;
                    last = this.d[this.m];
                    for (let j=1;j<=fadeT;j++) {
                        this.d[this.m+j] = last+(num-last)*j/fadeT;
                    }
                    this.m+=fadeT;
                    this.d[this.m] = num;
                }
            } else if (data[i].includes("%")) {
                detail = data[i].split("%");
                fadeT = Number(detail[0]);
                if (dataType==0) {
                    num = Number(detail[1]);
                    last = this.d[this.m];
                    for (let j=1;j<=fadeT;j++) {
                        this.d[this.m+j] = num-(num-last)*Math.sqrt(1-Math.pow(j/fadeT,2));
                    }
                    this.m+=fadeT;
                    this.d[this.m] = num;
                } else if (dataType==1) {
                    num = QJ.BL.hexToRgb(detail[1]);
                    last = QJ.BL.hexToRgb(this.d[this.m])//[0,{r:0,g:0,b:0}];
                    for (let j=1,xs;j<=fadeT;j++) {
                        xs = Math.sqrt(1-Math.pow(j/fadeT,2));
                        this.d[this.m+j] = QJ.BL.rgbToHex({
                            r:Math.floor(num.r-(num.r-last.r)*xs),
                            g:Math.floor(num.g-(num.g-last.g)*xs),
                            b:Math.floor(num.b-(num.b-last.b)*xs)
                        });
                    }
                    this.m+=fadeT;
                    this.d[this.m] = detail[1];
                } else if (dataType==2) {
                    num = Number(detail[1])*Math.PI/180;
                    last = this.d[this.m];
                    for (let j=1;j<=fadeT;j++) {
                        this.d[this.m+j] = num-(num-last)*Math.sqrt(1-Math.pow(j/fadeT,2));
                    }
                    this.m+=fadeT;
                    this.d[this.m] = num;
                }
            }
        }
    } else {
        this.isMode = false;
        let num;
        if (dataType==0) num = Number(orginData);
        else if (dataType==1) num = orginData;
        else if (dataType==2) num = Number(orginData)*Math.PI/180;
        this.d[this.m] = num;
    }
};
QJFrame.prototype.get = function() {
    if (this.t>this.m) this.t = 0;
    if (this.d[this.t]!=undefined) this.rt = this.t;
    this.t++;
    return this.d[this.rt];
};
QJFrame.prototype.getOnly = function() {
    return this.d[this.rt];
};
QJFrame.prototype.getTar = function(i) {
    return this.d[i>this.m?0:i];
};
//=============================================================================
//Spriteset_Map
//=============================================================================
Spriteset_Map.prototype.clearAllButtle = function() {
    this._upperBulletContainer.removeChildren();
    this._lowerBulletContainer.removeChildren();
    this._parallaxBulletContainer.removeChildren();
    this._mapBulletContainer.removeChildren();
};
const QJB_Spriteset_Map_createParallax = Spriteset_Map.prototype.createParallax;
Spriteset_Map.prototype.createParallax = function() {
    QJB_Spriteset_Map_createParallax.call(this);
    this._parallaxBulletContainer = new Sprite_QJContainer();
    this._parallaxBulletContainerParticle = new Sprite_QJContainer(true);
    this._baseSprite.addChild(this._parallaxBulletContainerParticle);
    this._baseSprite.addChild(this._parallaxBulletContainer);
};
const QJB_Spriteset_creatBullets = Spriteset_Map.prototype.createCharacters;
Spriteset_Map.prototype.createCharacters = function() {
    this._mapBulletContainer = new Sprite_QJContainer();
    this._mapBulletContainerParticle = new Sprite_QJContainer(true);
    this._mapBulletContainer.z = 0.5;
    this._mapBulletContainerParticle.z = 0.5;
    this._tilemap.addChild(this._mapBulletContainerParticle);
    this._tilemap.addChild(this._mapBulletContainer);
    QJB_Spriteset_creatBullets.call(this);
    this._lowerBulletContainer = new Sprite_QJContainer();
    this._lowerBulletContainerParticle = new Sprite_QJContainer(true);
    this.addChild(this._lowerBulletContainerParticle);
    this.addChild(this._lowerBulletContainer);
};
const QJB_Spriteset_Base_createTimer = Spriteset_Base.prototype.createTimer;
Spriteset_Base.prototype.createTimer = function() {
    QJB_Spriteset_Base_createTimer.call(this);
    this._upperBulletContainer = new Sprite_QJContainer();
    this._upperBulletContainerParticle = new Sprite_QJContainer(true);
    this.addChild(this._upperBulletContainerParticle);
    this.addChild(this._upperBulletContainer);
    this.recreateBullets();
};
Spriteset_Map.prototype.recreateBullets = function() {
    $gameMap.recreateBullets(this);
};
Spriteset_Map.prototype.createBullet = function(index) {
    let data,spriteData;
    if (typeof index == "object") {
        data = index;
        index = data.index;
    } else {
        data=$gameMap._mapBullets[index];
    }
    let type = data.bulletMode;
    if (!type) spriteData=new Sprite_QJBullet(index);
    else if (type==1) spriteData=new Sprite_QJLaser(index);
    else if (type==2) spriteData=new Sprite_QJTwoPoint(index);
    if (data.data.z=="T") {
        this._parallaxBulletContainer.addChild(spriteData);
        spriteData.particleParent = this._parallaxBulletContainerParticle;
    } else if (data.data.z=="M") {
        this._mapBulletContainer.addChild(spriteData);
        spriteData.particleParent = this._mapBulletContainerParticle;
    } else if (data.data.z=="P") {
        this._upperBulletContainer.addChild(spriteData);
        spriteData.particleParent = this._upperBulletContainerParticle;
    } else {
        this._lowerBulletContainer.addChild(spriteData);
        spriteData.particleParent = this._lowerBulletContainerParticle;
    }
};
//=============================================================================
//Sprite_QJContainer
//=============================================================================
function Sprite_QJContainer() {
    this.initialize.apply(this, arguments);
};
Sprite_QJContainer.prototype = Object.create(PIXI.Container.prototype);
Sprite_QJContainer.prototype.constructor = Sprite_QJContainer;
Sprite_QJContainer.prototype.initialize = function() {
    PIXI.Container.call(this);
    this.list={};
}
Sprite_QJContainer.prototype.addChildrenAtId = function(bulletSprite) {
    let bulletSpriteId=bulletSprite.QJParentid;
    if (this.list[bulletSpriteId]) {
        this.list[bulletSpriteId].addChild(bulletSprite);
    } else{
        let newContainer=new Sprite_QJPContainer(bulletSpriteId);
        this.addChild(newContainer);
        newContainer.addChild(bulletSprite);
        this.list[bulletSpriteId]=newContainer;
    }
};
Sprite_QJContainer.prototype.update = function() {
    this.children.forEach(function(child) {
        if (child.update) {
            child.update();
        }
    });
    if (this.AIBitmap) this.AIBitmap.clear();
    //Separate update and updateAfterImage in order to forbid the flicker of afterimage.
    //I rule out the probable reason such as canvas drawing and basecontext update.
    //But i don`t know the real reason.
    let isLowEffect = Graphics.isFPSTooLowQJ();
    this.children.forEach(isLowEffect?(child)=>{
        if (child.updateQuadraticCurve) {
            child.updateQuadraticCurve();
        }
        if (child.updateBrokenLine) {
            child.updateBrokenLine();
        }
    }:(child)=>{
        if (child.updateAfterImage) {
            child.updateAfterImage();
        }
        if (child.updateQuadraticCurve) {
            child.updateQuadraticCurve();
        }
        if (child.updateBrokenLine) {
            child.updateBrokenLine();
        }
    });
    if (this.AIBitmap) this.AIBitmap._setDirty();
};
Sprite_QJContainer.prototype.generateBitmap = function() {
    this.AIBitmap = new Bitmap(Graphics.width+48*2,Graphics.height);
    let spriteAI = new Sprite(this.AIBitmap);
    spriteAI.x = -48;
    this.addChild(spriteAI);
};
Sprite_QJContainer.prototype.drawAfterImage = function(x,y,r,c,o,w,h) {
    if (!this.AIBitmap) this.generateBitmap();
    let ctx = this.AIBitmap._context;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(r);
    ctx.fillStyle = c;
    ctx.globalAlpha = o;
    ctx.fillRect(-w/2,0,w,h);
    ctx.restore();
};
Sprite_QJContainer.prototype.drawQuadraticCurve = function(x,y,r,source,o,w,h,rect) {
    if (!this.AIBitmap) this.generateBitmap();
    let ctx = this.AIBitmap._context;
    ctx.save();
    //cst.globalCompositeOperation = 'source-over';
    ctx.translate(x,y);
    ctx.rotate(r);
    //ctx.fillStyle = c;
    ctx.globalAlpha = o;
    ctx.drawImage(source._canvas,rect[0],rect[1],rect[2],rect[3],-w/2,0,w,h);
    ctx.restore();
};
Sprite_QJContainer.prototype.drawSimpeRectangle = function(x,y,w,h,c = "#00ff00") {
    if (!this.AIBitmap) this.generateBitmap();
    let ctx = this.AIBitmap._context;
    ctx.save();
    ctx.fillStyle = c;
    ctx.fillRect(x, y, w, h);
    ctx.restore();
};
//=============================================================================
//Sprite_QJPContainer
//=============================================================================
function Sprite_QJPContainer() {
    this.initialize.apply(this, arguments);
};
Sprite_QJPContainer.prototype = Object.create(PIXI.particles.ParticleContainer.prototype);
Sprite_QJPContainer.prototype.constructor = Sprite_QJPContainer;
Sprite_QJPContainer.prototype.initialize = function(id) {
    PIXI.particles.ParticleContainer.call(this,10000,{
        rotation:true,
        scale:true,
        alpha:true,
        uvs:true
    });
    this.QJParentid=id;
};
Sprite_QJPContainer.prototype.update = function() {
    this.children.forEach(function(child) {
        if (child.update) {
            child.update();
        }
    });
};
//=============================================================================
//
//=============================================================================
const BL_Game_Variables_initialize = Game_Variables.prototype.initialize;
Game_Variables.prototype.initialize = function() {
    BL_Game_Variables_initialize.call(this);
    QJ.BL.initParam(this);
};
QJ.BL.initParam=function(gameVariables) {
    if (!gameVariables._playerInitBox) {
        gameVariables._playerInitBox=String(parameters['playerInitBox']) || "C[24]";
    }
    if (!gameVariables._playerInitBoxOffsetX) {
        gameVariables._playerInitBoxOffsetX=Number(parameters['playerInitBoxOffsetX']) || 0;
    }
    if (!gameVariables._playerInitBoxOffsetY) {
        gameVariables._playerInitBoxOffsetY=Number(parameters['playerInitBoxOffsetY']) || 0;
    }
    if (!gameVariables._eventInitBox) {
        gameVariables._eventInitBox=String(parameters['eventInitBox']) || "C[24]";
    }
    if (!gameVariables._eventInitBoxOffsetX) {
        gameVariables._eventInitBoxOffsetX=Number(parameters['eventInitBoxOffsetX']) || 0;
    }
    if (!gameVariables._eventInitBoxOffsetY) {
        gameVariables._eventInitBoxOffsetY=Number(parameters['eventInitBoxOffsetY']) || 0;
    }
}
QJ.BL.setDefaultEventBox=function(collisionBox,offsetx,offsety) {
    $gameVariables._eventInitBox=String(collisionBox) || "C[24]";
    $gameVariables._eventInitBoxOffsetX=Number(offsetx) || 0;
    $gameVariables._eventInitBoxOffsetY=Number(offsety) || 0;
    for (let i of $gameMap.events()) {
        i.refreshBodyBox();
    }
}
QJ.BL.setPlayerBox=function(collisionBox,offsetx,offsety) {
    $gameVariables._playerInitBox=String(collisionBox) || "C[24]";
    $gameVariables._playerInitBoxOffsetX=Number(offsetx) || 0;
    $gameVariables._playerInitBoxOffsetY=Number(offsety) || 0;
    $gamePlayer.refreshBodyBox();
}
//=============================================================================
//Game_CharacterBase.not consider jump now. 
//=============================================================================
Game_CharacterBase.prototype.boxShiftY = function() {
    return offsetGY?(this.isObjectCharacter() ? 0 : 6):0;
};
Game_CharacterBase.prototype.boxScreenSubX = function() {
    return (this._x + 0.5 - $gameMap.displayX()) * tileSize + this.boxOffsetX;
};
Game_CharacterBase.prototype.boxScreenSubY = function() {
    return (this._y + 0.5 - $gameMap.displayY()) * tileSize + this.boxOffsetY - this.boxShiftY() - this.jumpHeight();
};
Game_CharacterBase.prototype.boxScreenSubRealX = function() {
    return (this._realX + 0.5 - $gameMap.displayX()) * tileSize + this.boxOffsetX;
};
Game_CharacterBase.prototype.boxScreenSubRealY = function() {
    return (this._realY + 0.5 - $gameMap.displayY()) * tileSize + this.boxOffsetY - this.boxShiftY() - this.jumpHeight();
};
Game_CharacterBase.prototype.boxScreenX = function() {
    return (this._x + 0.5) * tileSize + this.boxOffsetX;
};
Game_CharacterBase.prototype.boxScreenY = function() {
    return (this._y + 0.5) * tileSize + this.boxOffsetY - this.boxShiftY() - this.jumpHeight();
};
Game_CharacterBase.prototype.boxScreenRealX = function() {
    return (this._realX + 0.5) * tileSize + this.boxOffsetX;
};
Game_CharacterBase.prototype.boxScreenRealY = function() {
    return (this._realY + 0.5) * tileSize + this.boxOffsetY - this.boxShiftY() - this.jumpHeight();
};
Game_Vehicle.prototype.boxScreenSubRealX = function() {
    return Game_Player.prototype.boxScreenSubRealX.call(this);
};
Game_Vehicle.prototype.boxScreenSubRealY = function() {
    return Game_Player.prototype.boxScreenSubRealY.call(this) - this._altitude;
};
//=============================================================================
//Game_Event
//=============================================================================
const QJB_Game_Character_update = Game_Character.prototype.update;
Game_Character.prototype.update = function() {
    QJB_Game_Character_update.call(this);
    if (this.QJBody) this.updateBodyPosition();
    else this.refreshBodyBox();
    if (this.shadowCircle) this.updateShadowCirccle();
};
Game_Character.prototype.updateBodyPosition = function() {
    QJ.BL.setPostion(this.QJBody,this.boxScreenRealX(),this.boxScreenRealY());
};
//=============================================================================
//Shadow
//=============================================================================
Game_Character.prototype.addShadowCircle = function(character,data,time,delta) {
    if (typeof time == "number") {
        this.shadowCircle = [0,1,delta,time,character,data];
    } else {
        if (time[0]==0&&this==$gamePlayer) return;
        this.shadowCircle = [1,1,delta,time,character,data];
    }
    this.updateShadowCirccle();
};
Game_Character.prototype.updateShadowCirccle = function() {
    let sc = this.shadowCircle;
    if (sc[0]==0) {
        sc[1]--;
        if (sc[1]<=0) {
            sc[3]--;
            sc[1]=sc[2];
            QJ.BL.Shadow(sc[4],sc[5]);
            if (sc[3]<=0) {
                this.shadowCircle = null;
            }
        }
    } else {
        if (QJ.BL.dealTimeBoolean(sc[3],this)) this.shadowCircle = null;
        else {
            sc[1]--;
            if (sc[1]<=0) {
                sc[1]=sc[2];
                QJ.BL.Shadow(sc[4],sc[5]);
            }
        }
    }
};
//=============================================================================
//refreshBodyBox
//=============================================================================
Game_Character.prototype.refreshBodyBox = function() {
    //Empty
};
Game_Player.prototype.refreshBodyBox = function() {
    //========================================
    this.boxOffsetX=$gameVariables._playerInitBoxOffsetX;
    this.boxOffsetY=$gameVariables._playerInitBoxOffsetY;
    let boxType = $gameVariables._playerInitBox;
    this.QJBody = QJ.BL.box(this.boxScreenX(),this.boxScreenY(),QJ.BL.dealCollisionBox(boxType));
    //========================================
};
Game_Event.prototype.refreshBodyBox = function() {
    //========================================
    let content="",detail;
    try {content=QJ.BL.getAnnotation(this);} catch(e) {content="";}
    //========================================
    this.boxOffsetX=$gameVariables._eventInitBoxOffsetX;
    this.boxOffsetY=$gameVariables._eventInitBoxOffsetY;
    let boxType = $gameVariables._eventInitBox;
    //========================================
    detail=content.match(/<BoxOffset:([^\,]+)\,([^\,\>]+)>/i);
    if (detail) {
        if (!isNaN(Number(detail[1]))&&!isNaN(Number(detail[2]))) {
            this.boxOffsetX=Number(detail[1]);
            this.boxOffsetY=Number(detail[2]);
        } 
    }
    //========================================
    detail=content.match(/<BoxType:([^\>]+)>/i);
    if (detail) {
        boxType=eval(detail[1]);
    }
    //========================================
    detail=content.match(/<laserObstacle>/i);
    if (detail) {
        this.laserObstacle = true;
    } else this.laserObstacle = false;
    //========================================
    this.QJBody = QJ.BL.box(this.boxScreenX(),this.boxScreenY(),QJ.BL.dealCollisionBox(boxType));
    //========================================
};
Game_Vehicle.prototype.refreshBodyBox = function() {
    this.boxOffsetX=0;
    this.boxOffsetY=0;
    this.QJBody = null;
};
Game_Follower.prototype.refreshBodyBox = function() {
    this.boxOffsetX=0;
    this.boxOffsetY=0;
    this.QJBody = null;
};
//=============================================================================
//erase
//=============================================================================
/*const QJC_Game_Event_erase = Game_Event.prototype.erase;
Game_Event.prototype.erase = function() {
    QJC_Game_Event_erase.call(this);
};*/
//=============================================================================
//Box Sprite.
//=============================================================================
if (canShowBox) {
    const QJC_Spriteset_Map_createLowerLayer = Spriteset_Map.prototype.createLowerLayer;
    Spriteset_Map.prototype.createLowerLayer = function() {
        QJC_Spriteset_Map_createLowerLayer.call(this);
        this._collisionBoxSprite = new Sprite_CollisiobBox();
        this.addChild(this._collisionBoxSprite);
    };
}
function Sprite_CollisiobBox() {
    this.initialize.apply(this, arguments);
}
Sprite_CollisiobBox.prototype = Object.create(Sprite.prototype);
Sprite_CollisiobBox.prototype.constructor = Sprite_CollisiobBox;
Sprite_CollisiobBox.prototype.initialize = function() {
    Sprite.prototype.initialize.call(this);
    this.visible = showBox;
    this.bitmap = new Bitmap(Graphics.width,Graphics.height);
    this.bitmap.paintOpacity = 80;
    QJ.BL.sprite = this;
};
Sprite_CollisiobBox.prototype.update = function() {
    Sprite.prototype.update.call(this);
    if (Input.isTriggered("F10")) {
        showBox=!showBox;
        this.bitmap.clear();
        this.visible = showBox;
    }
    if (this.visible) {
        this.bitmap.clear();
        let dx = -$gameMap.displayX()*tileSize;
        let dy = -$gameMap.displayY()*tileSize;
        if ($gamePlayer.QJBody) this.drawBody($gamePlayer.QJBody,this.bitmap._context,dx,dy,'#ff0000');
        for (let i=0,el=$gameMap._events,ell=el.length;i<ell;i++) {
            if (!el[i]||!el[i].QJBody) continue;
            this.drawBody(el[i].QJBody,this.bitmap._context,dx,dy,'#ff0000');
        }
        let tempList = $gameMap._mapBullets;
        for (let i in tempList) {
            if (!tempList[i]||!tempList[i].QJBody) continue;
            this.drawBody(tempList[i].QJBody,this.bitmap._context,dx,dy);
        }
    }
};
//QJ.BL.sprite.aBody(body);
Sprite_CollisiobBox.prototype.aBody = function(body) {
    this.bitmap.clear();
    let dx = -$gameMap.displayX()*tileSize;
    let dy = -$gameMap.displayY()*tileSize;
    this.drawBody(body,this.bitmap._context,dx,dy);
};
Sprite_CollisiobBox.prototype.drawBodies = function(list,c,dx,dy,color) {
    for (let i of list) {
        if (i) {
            this.drawBody(i,c,dx,dy,color);
        }
    }
};
Sprite_CollisiobBox.prototype.drawBody = function(body,c,dx,dy,color) {
    let posX = body.pos.x+dx,posY = body.pos.y+dy;
    c.beginPath();
    if (body.type==0) {//Circle 
        c.arc(posX,posY,body.r,0,2*Math.PI);
    } else if (body.type==1) {//Rectangle
        let bounds = body.calcPoints;
        c.moveTo(bounds[0].x+posX,bounds[0].y+posY);
        for (let j=1,jl=bounds.length;j<jl;j++) {
            c.lineTo(bounds[j].x+posX,bounds[j].y+posY);
        }
        c.lineTo(bounds[0].x+posX,bounds[0].y+posY);
    }
    c.closePath();
    c.fillStyle = color?color:(body.color?body.color:"#00FF00");
    c.fill();
    c.lineWidth = 2;
    c.strokeStyle = "#000000";
    c.stroke();
};
//=============================================================================
//
//=============================================================================
})();
//=============================================================================
//
//=============================================================================